目录结构:
.
├── app
│   ├── config_loader.go
│   ├── lifecycle.go
│   ├── signal_handler.go
│   └── startup.go
├── config
│   └── config.go
├── core
│   └── workspace.go
├── database
│   ├── model
│   │   ├── data_library.go
│   │   ├── task_reports.go
│   │   └── task_similarity.go
│   ├── mysql.go
│   └── repository
│       ├── data_library_repository.go
│       ├── task_reports_repository.go
│       └── task_similarity_repository.go
├── initializer
│   └── manager.go
├── logic
│   ├── common.go
│   └── consume.go
├── mq
│   ├── rabbitmq.go
│   ├── similarity_request.go
│   └── similarity_response.go
├── nacos
│   ├── nacos.go
│   ├── registry.go
│   └── service_registry.go
├── similarity
│   └── similarity.go
├── svc
│   └── servicecontext.go
└── utils
    └── snowflake.go

==================================================


文件: app\config_loader.go
--------------------------------------------------
package app

import (
	"fmt"
	"similarity-service/internal/config"
	"similarity-service/internal/nacos"

	"github.com/zeromicro/go-zero/core/conf"
	"github.com/zeromicro/go-zero/core/logx"
)

// ConfigLoader 配置加载器
type ConfigLoader struct {
	configFile string
	useNacos   bool
}

// NewConfigLoader 创建配置加载器
func NewConfigLoader(configFile string, useNacos bool) *ConfigLoader {
	return &ConfigLoader{
		configFile: configFile,
		useNacos:   useNacos,
	}
}

// Load 加载配置
func (cl *ConfigLoader) Load() (*config.Config, *nacos.ConfigManager, error) {
	var localConfig config.Config

	if cl.useNacos {
		fmt.Println("正在使用 Nacos 配置中心启动应用...")

		config, manager, err := cl.loadFromNacos()
		if err != nil {
			logx.Errorf("从 Nacos 加载配置失败，回退到本地配置: %v", err)
			// 回退到本地配置
			conf.MustLoad(cl.configFile, &localConfig)
			return &localConfig, nil, nil
		}
		return config, manager, nil
	} else {
		// 使用本地配置
		conf.MustLoad(cl.configFile, &localConfig)
		fmt.Println("从本地文件加载配置")
		return &localConfig, nil, nil
	}
}

// loadFromNacos 从 Nacos 加载配置
func (cl *ConfigLoader) loadFromNacos() (*config.Config, *nacos.ConfigManager, error) {
	// 先加载本地配置获取 Nacos 连接信息
	var bootstrapConfig config.Config
	if err := conf.Load(cl.configFile, &bootstrapConfig); err != nil {
		return nil, nil, fmt.Errorf("加载本地配置文件失败: %w", err)
	}

	// 验证 Nacos 配置
	if err := cl.validateNacosConfig(bootstrapConfig.Nacos); err != nil {
		return nil, nil, err
	}

	// 初始化 Nacos 配置管理器
	nacosManager, err := nacos.NewNacosConfigManager(
		bootstrapConfig.Nacos.ServerAddr,
		bootstrapConfig.Nacos.Username,
		bootstrapConfig.Nacos.Password,
		bootstrapConfig.Nacos.Namespace,
		bootstrapConfig.Nacos.Group,
	)
	if err != nil {
		return nil, nil, fmt.Errorf("创建 Nacos 配置管理器失败: %w", err)
	}

	// 从 Nacos 获取配置
	configContent, err := nacosManager.GetConfig(bootstrapConfig.Nacos.DataId)
	if err != nil {
		return nil, nil, fmt.Errorf("从 Nacos 获取配置失败: %w", err)
	}

	// 解析 Nacos 配置
	var nacosConfig config.Config
	if err := conf.LoadFromYamlBytes([]byte(configContent), &nacosConfig); err != nil {
		return nil, nil, fmt.Errorf("解析 Nacos 配置失败: %w", err)
	}

	// 确保 Nacos 配置本身也包含正确的 Nacos 连接信息（用于后续监听）
	nacosConfig.Nacos = bootstrapConfig.Nacos

	fmt.Println("从 Nacos 成功加载配置")
	return &nacosConfig, nacosManager, nil
}

// validateNacosConfig 验证 Nacos 配置
func (cl *ConfigLoader) validateNacosConfig(nacosConfig config.NacosConfig) error {
	if nacosConfig.ServerAddr == "" {
		return fmt.Errorf("使用 nacos 时必须配置 Nacos 服务器地址")
	}

	if nacosConfig.DataId == "" {
		return fmt.Errorf("使用 nacos 时必须配置 Nacos dataId")
	}

	return nil
}

// LoadLocalConfig 加载本地配置（用于回退）
func (cl *ConfigLoader) LoadLocalConfig() (*config.Config, error) {
	var localConfig config.Config
	if err := conf.Load(cl.configFile, &localConfig); err != nil {
		return nil, fmt.Errorf("加载本地配置文件失败: %w", err)
	}
	return &localConfig, nil
}


文件: app\lifecycle.go
--------------------------------------------------
package app

import (
	"context"
	"similarity-service/internal/config"
	"similarity-service/internal/logic"
	"similarity-service/internal/svc"
	"sync"

	"github.com/zeromicro/go-zero/core/logx"
)

// LifecycleManager 服务生命周期管理器
type LifecycleManager struct {
	serviceCtx   *svc.ServiceContext
	consumeLogic *logic.ConsumeLogic
	mutex        sync.RWMutex
	restartChan  chan struct{}
}

// NewLifecycleManager 创建生命周期管理器
func NewLifecycleManager() *LifecycleManager {
	return &LifecycleManager{
		restartChan: make(chan struct{}, 1),
	}
}

// InitializeServices 初始化服务组件
func (lm *LifecycleManager) InitializeServices(c config.Config) error {
	lm.mutex.Lock()
	defer lm.mutex.Unlock()

	// 关闭旧的服务实例（如果存在）
	if lm.serviceCtx != nil {
		lm.shutdownServices()
	}

	// 创建新的服务实例
	lm.serviceCtx = svc.NewServiceContext(c)
	lm.consumeLogic = logic.NewConsumeLogic(context.Background(), lm.serviceCtx)

	return nil
}

// StartConsumer 启动消费者
func (lm *LifecycleManager) StartConsumer() {
	lm.mutex.RLock()
	logicInstance := lm.consumeLogic
	lm.mutex.RUnlock()

	if logicInstance != nil {
		go logicInstance.StartConsuming()
	}
}

// ShutdownServices 关闭服务组件
func (lm *LifecycleManager) ShutdownServices() {
	lm.mutex.Lock()
	defer lm.mutex.Unlock()

	lm.shutdownServices()
}

// RestartServices 重启服务
func (lm *LifecycleManager) RestartServices(newConfig config.Config) {
	logx.Info("正在使用新配置重启服务...")

	// 停止当前服务
	lm.ShutdownServices()

	// 使用新配置重新初始化服务
	if err := lm.InitializeServices(newConfig); err != nil {
		logx.Errorf("重新初始化服务失败: %v", err)
		return
	}

	// 重新启动消费者
	lm.StartConsumer()

	logx.Info("服务使用新配置重启成功")
}

// shutdownServices 内部关闭服务方法
func (lm *LifecycleManager) shutdownServices() {
	if lm.serviceCtx != nil {
		// 关闭 RabbitMQ 连接
		if lm.serviceCtx.CommonChannel() != nil {
			if err := lm.serviceCtx.CommonChannel().Close(); err != nil {
				logx.Errorf("关闭 CommonChannel RabbitMQ 连接失败: %v", err)
			}
		}
		if lm.serviceCtx.RabbitMQ() != nil {
			if err := lm.serviceCtx.RabbitMQ().Close(); err != nil {
				logx.Errorf("关闭 RabbitMQ 连接失败: %v", err)
			}
		}

		// 注销服务
		if lm.serviceCtx.Initializer.GetServiceReRegistry() != nil {
			if err := lm.serviceCtx.Initializer.GetServiceReRegistry().Deregister(); err != nil {
				logx.Errorf("服务注销失败: %v", err)
			} else {
				logx.Info("服务已从 Nacos 注销")
			}
		}
	}

	// 关闭重启通道
	if lm.restartChan != nil {
		close(lm.restartChan)
		lm.restartChan = nil
	}

	lm.serviceCtx = nil
	lm.consumeLogic = nil
}


文件: app\signal_handler.go
--------------------------------------------------
package app

import (
	"os"
	"os/signal"
	"syscall"
)

// SignalHandler 信号处理器
type SignalHandler struct {
	shutdownCallback func()
}

// NewSignalHandler 创建信号处理器
func NewSignalHandler() *SignalHandler {
	return &SignalHandler{}
}

// SetShutdownCallback 设置关闭回调函数
func (sh *SignalHandler) SetShutdownCallback(callback func()) {
	sh.shutdownCallback = callback
}

// WaitForSignal 等待信号
func (sh *SignalHandler) WaitForSignal() {
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT)
	
	// 等待信号
	<-ch
	
	// 执行关闭回调
	if sh.shutdownCallback != nil {
		sh.shutdownCallback()
	}
}

文件: app\startup.go
--------------------------------------------------
package app

import (
	"fmt"
	"similarity-service/internal/config"
	"similarity-service/internal/nacos"

	"github.com/zeromicro/go-zero/core/conf"
	"github.com/zeromicro/go-zero/core/logx"
)

// AppManager 应用管理器
type AppManager struct {
	configFile string
	useNacos   bool
	config     *config.Config
	nacosMgr   *nacos.ConfigManager
	lifecycle  *LifecycleManager
}

// NewAppManager 创建应用管理器
func NewAppManager(configFile string, useNacos bool) *AppManager {
	return &AppManager{
		configFile: configFile,
		useNacos:   useNacos,
		lifecycle:  NewLifecycleManager(),
	}
}

// Run 启动应用
func (am *AppManager) Run() error {
	// 加载配置
	if err := am.loadConfig(); err != nil {
		return fmt.Errorf("加载配置失败: %w", err)
	}

	// 初始化服务
	if err := am.lifecycle.InitializeServices(*am.config); err != nil {
		return fmt.Errorf("初始化服务失败: %w", err)
	}

	// 启动配置监听（如果使用 Nacos）
	if am.useNacos && am.nacosMgr != nil && am.config.Nacos.DataId != "" {
		if err := am.startConfigListener(); err != nil {
			logx.Errorf("启动配置监听失败: %v", err)
		}
	}

	// 启动消费者
	am.lifecycle.StartConsumer()

	// 等待退出信号
	am.waitForShutdown()

	return nil
}

// loadConfig 加载配置
func (am *AppManager) loadConfig() error {
	configLoader := NewConfigLoader(am.configFile, am.useNacos)

	config, nacosMgr, err := configLoader.Load()
	if err != nil {
		return err
	}

	am.config = config
	am.nacosMgr = nacosMgr
	return nil
}

// startConfigListener 启动配置监听
func (am *AppManager) startConfigListener() error {
	onConfigChange := func(newConfigContent string) {
		logx.Info("收到 Nacos 配置变更通知")

		var newConfig config.Config
		if err := conf.LoadFromYamlBytes([]byte(newConfigContent), &newConfig); err != nil {
			logx.Errorf("解析更新后的 Nacos 配置失败: %v", err)
			return
		}

		logx.Infof("配置更新成功，正在重启服务...")
		am.lifecycle.RestartServices(newConfig)

		// 更新当前配置
		am.config = &newConfig
	}

	if err := am.nacosMgr.ListenConfig(am.config.Nacos.DataId, onConfigChange); err != nil {
		return fmt.Errorf("监听配置变更失败: %w", err)
	}

	logx.Infof("已开始监听配置变更，数据ID: %s", am.config.Nacos.DataId)
	return nil
}

// waitForShutdown 等待关闭信号
func (am *AppManager) waitForShutdown() {
	signalHandler := NewSignalHandler()

	// 设置关闭回调
	signalHandler.SetShutdownCallback(func() {
		fmt.Println("正在关闭服务...")

		// 取消配置监听
		if am.nacosMgr != nil && am.config.Nacos.DataId != "" {
			if err := am.nacosMgr.CancelListenConfig(am.config.Nacos.DataId); err != nil {
				logx.Errorf("取消配置监听失败: %v", err)
			}
		}

		// 关闭服务
		am.lifecycle.ShutdownServices()
		fmt.Println("服务已退出")
	})

	// 等待信号
	signalHandler.WaitForSignal()
}


文件: config\config.go
--------------------------------------------------
package config

import (
	"github.com/zeromicro/go-zero/rest"
)

type NacosConfig struct {
	ServerAddr string `json:",optional"` // 120.26.180.149:8848
	Username   string `json:",optional"` // 可选
	Password   string `json:",optional"` // 可选
	Namespace  string `json:",optional"` // 8fee08f3-44ea-4e26-a9b5-530c582330a3
	Group      string `json:",default=DEFAULT_GROUP"`
	DataId     string `json:",optional"`
}

// MySQL 配置
type MySQLConfig struct {
	Host            string `json:",default=127.0.0.1:3306"`
	Username        string `json:",default=root"`
	Password        string `json:",optional"`
	Database        string `json:",default="`
	Charset         string `json:",default=utf8mb4"`
	ParseTime       bool   `json:",default=true"`
	Loc             string `json:",default=Local"`
	MaxIdleConns    int    `json:",default=10"`
	MaxOpenConns    int    `json:",default=100"`
	ConnMaxLifetime string `json:",default=1h"`
}

type RabbitMQConfig struct {
	Host        string `json:",optional"` // 主机地址
	VirtualHost string `json:",optional"` // 虚拟主机
	// 常规队列
	Common struct {
		SimilarityExchange   string `json:",optional"`
		SimilarityQueue      string `json:",optional"`
		SimilarityRoutingKey string `json:",optional"`
		ResultExchange       string `json:",optional"`
		ResultQueue          string `json:",optional"`
		ResultRoutingKey     string `json:",optional"`
	} `json:",optional"`
}

// 配置队列
type Config struct {
	rest.RestConf
	Nacos    NacosConfig
	MySQL    MySQLConfig    `json:",optional"` // MySQL 配置
	RabbitMQ RabbitMQConfig `json:",optional"`
}


文件: core\workspace.go
--------------------------------------------------
package core

import (
	"context"
	"encoding/json"
	"github.com/zeromicro/go-zero/core/logx"
	"math"
	"runtime"
	"similarity-service/internal/config"
	"similarity-service/internal/database/model"
	"similarity-service/internal/mq"
	"similarity-service/internal/similarity"
	"similarity-service/internal/svc"
	"similarity-service/internal/utils"
	"sync"
	"time"
)

// WorkspaceManager 工作空间管理器，负责工作空间的创建和清理
type WorkspaceManager struct {
	workspaces sync.Map // 存储活跃的工作空间
	basePath   string
	mu         sync.RWMutex
}

var (
	workspaceManager *WorkspaceManager
	once             sync.Once
)

func GetWorkspaceManager(basePath string) *WorkspaceManager {
	once.Do(func() {
		workspaceManager = &WorkspaceManager{
			basePath: basePath,
		}
	})
	return workspaceManager
}

type Workspace struct {
	ctx               context.Context
	config            config.Config
	startTime         time.Time
	similarityMessage mq.SimilarityMessage
	svcCtx            *svc.ServiceContext
	mu                sync.RWMutex // 工作空间内部锁
	isCleaned         bool         // 标记是否已清理
}

// NewWorkspace 创建工作空间,上下文/配置/提交信息,返回 工作空间实例 和 提交信息
func NewWorkspace(ctx context.Context, config config.Config, similarityMessage mq.SimilarityMessage, svcCtx *svc.ServiceContext) (*Workspace, *mq.SimilarityResultMessage) {
	ws := &Workspace{
		ctx:               ctx,        // 使用传入的ctx
		startTime:         time.Now(), // 记录开始时间，用来计算任务总耗时
		config:            config,     // 系统配置
		similarityMessage: similarityMessage,
		svcCtx:            svcCtx,
		isCleaned:         false,
	}
	return ws, nil
}

// buildErrorResponse 构建错误响应
func (w *Workspace) buildErrorResponse() *mq.SimilarityResultMessage {
	return &mq.SimilarityResultMessage{
		TaskID:         w.similarityMessage.TaskID,
		SubmitID:       w.similarityMessage.SubmitID,
		SetID:          w.similarityMessage.SetID,
		ProblemID:      w.similarityMessage.ProblemID,
		IsSet:          w.similarityMessage.IsSet,
		Language:       w.similarityMessage.Language,
		UserID:         w.similarityMessage.UserID,
		MinMatchLength: w.similarityMessage.MinMatchLength,
		Threshold:      w.similarityMessage.Threshold,
		TaskType:       w.similarityMessage.TaskType,
		CodeTokens:     w.similarityMessage.CodeTokens,
		CodeTokenNames: w.similarityMessage.CodeTokenNames,
		CodeTokenTexts: w.similarityMessage.CodeTokenTexts,
		Similarity:     0.0,
		Skip:           false,
	}
}

// buildErrorResponse 构建错误响应
func (w *Workspace) buildSkipResponse() *mq.SimilarityResultMessage {
	return &mq.SimilarityResultMessage{
		TaskID:         w.similarityMessage.TaskID,
		SubmitID:       w.similarityMessage.SubmitID,
		SetID:          w.similarityMessage.SetID,
		ProblemID:      w.similarityMessage.ProblemID,
		IsSet:          w.similarityMessage.IsSet,
		Language:       w.similarityMessage.Language,
		UserID:         w.similarityMessage.UserID,
		MinMatchLength: w.similarityMessage.MinMatchLength,
		Threshold:      w.similarityMessage.Threshold,
		TaskType:       w.similarityMessage.TaskType,
		CodeTokens:     w.similarityMessage.CodeTokens,
		CodeTokenNames: w.similarityMessage.CodeTokenNames,
		CodeTokenTexts: w.similarityMessage.CodeTokenTexts,
		Similarity:     0.0,
		Skip:           true,
	}
}

// buildErrorResponse 构建响应
func (w *Workspace) buildResponse(similarity float64) *mq.SimilarityResultMessage {
	return &mq.SimilarityResultMessage{
		TaskID:         w.similarityMessage.TaskID,
		SubmitID:       w.similarityMessage.SubmitID,
		SetID:          w.similarityMessage.SetID,
		ProblemID:      w.similarityMessage.ProblemID,
		IsSet:          w.similarityMessage.IsSet,
		Language:       w.similarityMessage.Language,
		UserID:         w.similarityMessage.UserID,
		MinMatchLength: w.similarityMessage.MinMatchLength,
		Threshold:      w.similarityMessage.Threshold,
		TaskType:       w.similarityMessage.TaskType,
		CodeTokens:     w.similarityMessage.CodeTokens,
		CodeTokenNames: w.similarityMessage.CodeTokenNames,
		CodeTokenTexts: w.similarityMessage.CodeTokenTexts,
		Similarity:     similarity,
		Skip:           false,
	}
}

func calculateSimilarityScorePrecise(matches int, submitTokens, libraryTokens []int) float64 {
	if matches == 0 {
		return 0.0
	}

	// 使用 int64 避免溢出
	matchesBig := int64(matches * 2)
	submitSize := int64(len(submitTokens))
	librarySize := int64(len(libraryTokens))

	denominator := submitSize + librarySize
	if denominator == 0 {
		return 0.0
	}

	similarity := float64(matchesBig) / float64(denominator)
	return math.Round(similarity*10000) / 10000 // 保留4位小数
}

// 执行代码
func (w *Workspace) Execute() *mq.SimilarityResultMessage {
	startTime := time.Now()
	logx.Infof("开始执行 %v", w.similarityMessage.TaskID)
	w.mu.Lock()
	defer w.mu.Unlock()

	sampleLibraries, err := w.svcCtx.DataLibraryRepo().GetSimilarityLibraries(
		w.similarityMessage.IsSet,
		w.similarityMessage.ProblemID,
		w.similarityMessage.Language,
		w.similarityMessage.UserID,
		w.similarityMessage.SetID,
		100,
	)

	if err != nil {
		logx.Errorf("获取样本库失败: %v", err)
		return nil
	}

	logx.Infof("样本库数量: %d", len(sampleLibraries))

	if len(sampleLibraries) == 0 {
		return w.buildSkipResponse()
	}

	var (
		maxSimilarityScore float64
		mu                 sync.Mutex
		taskSimilarities   []*model.TaskSimilarity // 用于收集 TaskSimilarity 记录
	)
	// 定义结果结构
	type similarityResult struct {
		similarityScore float64
		library         model.DataLibrary
	}

	// 使用 worker pool
	numWorkers := runtime.NumCPU() * 2
	jobs := make(chan model.DataLibrary, len(sampleLibraries))
	results := make(chan *similarityResult, len(sampleLibraries))

	// 启动 worker
	for i := 0; i < numWorkers; i++ {
		go func() {
			for library := range jobs {
				// 解析 CodeToken JSON 字符串为 []int
				var codeTokens []int
				if err := json.Unmarshal([]byte(library.CodeToken), &codeTokens); err != nil {
					logx.Infof("解析 CodeToken JSON 失败 (ID: %s): %v", library.ID, err)
					results <- &similarityResult{similarityScore: 0.0, library: library}
					continue
				}

				matches := similarity.GreedyStringTiling(w.similarityMessage.CodeTokens, codeTokens, 5)
				similarityScore := calculateSimilarityScorePrecise(
					matches,
					w.similarityMessage.CodeTokens,
					codeTokens,
				)
				results <- &similarityResult{similarityScore: similarityScore, library: library}
			}
		}()
	}

	// 分发任务
	go func() {
		for _, library := range sampleLibraries {
			jobs <- library
		}
		close(jobs)
	}()

	// 收集结果
	for i := 0; i < len(sampleLibraries); i++ {
		result := <-results

		// 更新最大相似度
		if result.similarityScore > maxSimilarityScore {
			maxSimilarityScore = result.similarityScore
		}

		// 创建 TaskSimilarity 记录
		taskSimilarity := w.createTaskSimilarity(result.library, result.similarityScore)

		mu.Lock()
		taskSimilarities = append(taskSimilarities, taskSimilarity)
		mu.Unlock()
	}

	//// 批量插入 TaskSimilarity 记录
	//if len(taskSimilarities) > 0 {
	//	if err := w.svcCtx.TaskSimilarityRepo().BatchCreate(taskSimilarities); err != nil {
	//		logx.Errorf("批量插入 TaskSimilarity 记录失败: %v", err)
	//	} else {
	//		logx.Infof("成功插入 %d 条 TaskSimilarity 记录", len(taskSimilarities))
	//	}
	//}

	// 批量插入 TaskSimilarity 记录 - 异步执行
	if len(taskSimilarities) > 0 {
		go func(records []*model.TaskSimilarity) {
			defer func() {
				if r := recover(); r != nil {
					logx.Errorf("异步插入 TaskSimilarity 时发生 panic: %v", r)
				}
			}()

			if err := w.svcCtx.TaskSimilarityRepo().BatchCreate(records); err != nil {
				logx.Errorf("批量插入 TaskSimilarity 记录失败: %v", err)
			} else {
				logx.Infof("成功插入 %d 条 TaskSimilarity 记录", len(records))
			}
		}(taskSimilarities) // 注意：这里传递副本，避免数据竞争
	}

	// 立即返回响应，不等待插入完成
	response := w.buildResponse(maxSimilarityScore)

	totalTime := time.Since(startTime)
	logx.Infof("Execute函数总执行耗时: %v", totalTime)
	return response
}

//// 创建 TaskSimilarity 记录
//func (w *Workspace) createTaskSimilarity(library model.DataLibrary, similarityScore float64) *model.TaskSimilarity {
//	now := time.Now()
//
//	// 确保 token 数组正确序列化为 JSON 数组
//	var submitCodeTokenJSON, originCodeTokenJSON []byte
//	var err error
//
//	//// 将 token 数组转换为 JSON 字符串
//	//submitCodeTokenJSON, _ := json.Marshal(w.similarityMessage.CodeTokens)
//	//originCodeTokenJSON, _ := json.Marshal(library.CodeToken)
//
//	// 处理 submitCodeToken - 确保是 []int 类型
//	if w.similarityMessage.CodeTokens == nil {
//		submitCodeTokenJSON, _ = json.Marshal([]int{})
//	} else {
//		submitCodeTokenJSON, err = json.Marshal(w.similarityMessage.CodeTokens)
//		if err != nil {
//			// 处理错误，确保是整数数组
//			submitCodeTokenJSON, _ = json.Marshal([]int{})
//		}
//	}
//
//	// 处理 originCodeToken - 确保是 []int 类型
//	if library.CodeToken == nil {
//		originCodeTokenJSON, _ = json.Marshal([]int{})
//	} else {
//		// 确保 library.CodeToken 是整数切片
//		originCodeTokenJSON, err = json.Marshal(library.CodeToken)
//		if err != nil {
//			originCodeTokenJSON, _ = json.Marshal([]int{})
//		}
//	}
//
//	submitTokenNames, _ := json.Marshal(w.similarityMessage.CodeTokenNames)
//	submitTokenTexts, _ := json.Marshal(w.similarityMessage.CodeTokenTexts)
//
//	return &model.TaskSimilarity{
//		ID:               utils.GenerateID(),
//		TaskID:           w.similarityMessage.TaskID,
//		TaskType:         w.similarityMessage.IsSet,
//		ProblemID:        w.similarityMessage.ProblemID,
//		SetID:            w.similarityMessage.SetID,
//		IsSet:            w.similarityMessage.IsSet,
//		Language:         w.similarityMessage.Language,
//		Similarity:       similarityScore,
//		SubmitUser:       w.similarityMessage.UserID,
//		SubmitCode:       w.similarityMessage.Code,
//		SubmitCodeLength: w.similarityMessage.CodeLength,
//		SubmitID:         w.similarityMessage.SubmitID,
//		SubmitTime:       &now,
//		SubmitCodeToken:  string(submitCodeTokenJSON),
//		SubmitTokenName:  string(submitTokenNames), // 根据实际情况设置
//		SubmitTokenTexts: string(submitTokenTexts), // 根据实际情况设置
//		OriginUser:       library.UserID,
//		OriginCode:       library.Code,
//		OriginCodeLength: len(library.Code),
//		OriginID:         library.ID,
//		OriginTime:       library.SubmitTime,
//		OriginCodeToken:  string(originCodeTokenJSON),
//		OriginTokenName:  library.CodeTokenName,  // 根据实际情况设置
//		OriginTokenTexts: library.CodeTokenTexts, // 根据实际情况设置
//		CreateTime:       &now,
//		CreateUser:       "0", // 根据实际情况设置
//		UpdateTime:       &now,
//		UpdateUser:       "0",
//	}
//}

// 创建 TaskSimilarity 记录
func (w *Workspace) createTaskSimilarity(library model.DataLibrary, similarityScore float64) *model.TaskSimilarity {
	now := time.Now()

	// 处理 submitCodeToken - 确保是有效的JSON数组
	var submitCodeTokenJSON []byte
	if w.similarityMessage.CodeTokens == nil {
		submitCodeTokenJSON, _ = json.Marshal([]int{})
	} else {
		submitCodeTokenJSON, _ = json.Marshal(w.similarityMessage.CodeTokens)
	}

	// 处理 originCodeToken - 确保是有效的JSON数组
	var originCodeTokenJSON []byte
	if library.CodeToken == "" {
		// 如果CodeToken是空字符串，存储空数组
		originCodeTokenJSON, _ = json.Marshal([]int{})
	} else {
		// 如果CodeToken已经有值，需要验证它是否是有效的JSON数组
		// 如果不是有效的JSON数组，可能需要解析并重新序列化
		var tokenArray []int
		err := json.Unmarshal([]byte(library.CodeToken), &tokenArray)
		if err != nil {
			// 如果不是有效的JSON，尝试其他解析方式或存储为空数组
			originCodeTokenJSON, _ = json.Marshal([]int{})
		} else {
			// 重新序列化确保格式正确
			originCodeTokenJSON, _ = json.Marshal(tokenArray)
		}
	}

	// 处理其他JSON字段
	submitTokenNames, _ := json.Marshal(w.similarityMessage.CodeTokenNames)
	if submitTokenNames == nil {
		submitTokenNames, _ = json.Marshal([]string{})
	}

	submitTokenTexts, _ := json.Marshal(w.similarityMessage.CodeTokenTexts)
	if submitTokenTexts == nil {
		submitTokenTexts, _ = json.Marshal([]string{})
	}

	// 处理OriginTokenName和OriginTokenTexts
	var originTokenNameJSON, originTokenTextsJSON []byte
	if library.CodeTokenName == "" {
		originTokenNameJSON, _ = json.Marshal([]string{})
	} else {
		originTokenNameJSON = []byte(library.CodeTokenName)
	}

	if library.CodeTokenTexts == "" {
		originTokenTextsJSON, _ = json.Marshal([]string{})
	} else {
		originTokenTextsJSON = []byte(library.CodeTokenTexts)
	}

	return &model.TaskSimilarity{
		ID:               utils.GenerateID(),
		TaskID:           w.similarityMessage.TaskID,
		TaskType:         w.similarityMessage.IsSet,
		ProblemID:        w.similarityMessage.ProblemID,
		SetID:            w.similarityMessage.SetID,
		IsSet:            w.similarityMessage.IsSet,
		Language:         w.similarityMessage.Language,
		Similarity:       similarityScore,
		SubmitUser:       w.similarityMessage.UserID,
		SubmitCode:       w.similarityMessage.Code,
		SubmitCodeLength: w.similarityMessage.CodeLength,
		SubmitID:         w.similarityMessage.SubmitID,
		SubmitTime:       &now,
		SubmitCodeToken:  string(submitCodeTokenJSON),
		SubmitTokenName:  string(submitTokenNames),
		SubmitTokenTexts: string(submitTokenTexts),
		OriginUser:       library.UserID,
		OriginCode:       library.Code,
		OriginCodeLength: len(library.Code),
		OriginID:         library.ID,
		OriginTime:       library.SubmitTime,
		OriginCodeToken:  string(originCodeTokenJSON),
		OriginTokenName:  string(originTokenNameJSON),
		OriginTokenTexts: string(originTokenTextsJSON),
		CreateTime:       &now,
		CreateUser:       "0",
		UpdateTime:       &now,
		UpdateUser:       "0",
	}
}

// 在Workspace结构体中添加报告生成方法
func (w *Workspace) GenerateReport(similarityResult *mq.SimilarityResultMessage) error {
	logx.Infof("开始生成报告 taskID: %s", w.similarityMessage.TaskID)
	// 设置阈值
	threshold := w.similarityMessage.Threshold
	now := time.Now()
	// 创建TaskReports记录
	taskReport := &model.TaskReports{
		ID:                     utils.GenerateID(),
		TaskID:                 w.similarityMessage.TaskID,
		ProblemID:              w.similarityMessage.ProblemID,
		SetID:                  w.similarityMessage.SetID,
		SimilarityDistribution: "[]",
		DegreeStatistics:       "[]",
		Threshold:              threshold,
		CreateTime:             &now,
		UpdateTime:             &now,
	}
	similarityResult.ReportID = taskReport.ID

	// 插入TaskReports记录
	if err := w.svcCtx.TaskReportsRepo().Create(taskReport); err != nil {
		logx.Errorf("插入TaskReports记录失败: %v", err)
		return err
	}

	logx.Infof("成功生成报告，报告ID: %s", taskReport.ID)
	return nil
}

// GetAllWorkspaces 获取所有工作空间（用于监控）
func (wm *WorkspaceManager) GetAllWorkspaces() []*Workspace {
	var workspaces []*Workspace
	wm.workspaces.Range(func(key, value interface{}) bool {
		if ws, ok := value.(*Workspace); ok {
			workspaces = append(workspaces, ws)
		}
		return true
	})
	return workspaces
}


文件: database\mysql.go
--------------------------------------------------
package database

import (
	"fmt"
	"log"
	"time"

	"similarity-service/internal/config"

	"github.com/zeromicro/go-zero/core/logx"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type MySQLManager struct {
	DB *gorm.DB
}

func NewMySQLManager(c config.MySQLConfig) (*MySQLManager, error) {
	dsn := buildDSN(c)

	db, err := connectMySQL(dsn, c)
	if err != nil {
		return nil, err
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	// 优化连接池配置以适应高并发
	sqlDB.SetMaxIdleConns(50)                 // 增加最大空闲连接数
	sqlDB.SetMaxOpenConns(200)                // 增加最大打开连接数
	sqlDB.SetConnMaxLifetime(5 * time.Minute) // 减少连接最大生存时间
	sqlDB.SetConnMaxIdleTime(2 * time.Minute) // 设置连接最大空闲时间

	// 测试连接
	if err := sqlDB.Ping(); err != nil {
		return nil, fmt.Errorf("数据库连接测试失败: %v", err)
	}

	logx.Info("MySQL 连接成功")
	return &MySQLManager{DB: db}, nil
}

func buildDSN(c config.MySQLConfig) string {
	return c.Username + ":" + c.Password + "@tcp(" + c.Host + ")/" + c.Database +
		"?charset=" + c.Charset + "&parseTime=" + boolToString(c.ParseTime) + "&loc=" + c.Loc
}

func connectMySQL(dsn string, c config.MySQLConfig) (*gorm.DB, error) {
	newLogger := logger.New(
		log.New(log.Writer(), "\r\n", log.LstdFlags),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)

	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		return nil, err
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	sqlDB.SetMaxIdleConns(c.MaxIdleConns)
	sqlDB.SetMaxOpenConns(c.MaxOpenConns)

	if maxLifetime, err := time.ParseDuration(c.ConnMaxLifetime); err == nil {
		sqlDB.SetConnMaxLifetime(maxLifetime)
	}

	return db, nil
}

func boolToString(b bool) string {
	if b {
		return "True"
	}
	return "False"
}

func (m *MySQLManager) IsReady() bool {
	return m.DB != nil
}

func (m *MySQLManager) SafeDB() (*gorm.DB, error) {
	if m.DB == nil {
		return nil, fmt.Errorf("数据库未初始化")
	}
	return m.DB, nil
}

func (m *MySQLManager) Close() error {
	if m.DB != nil {
		sqlDB, err := m.DB.DB()
		if err != nil {
			return err
		}
		return sqlDB.Close()
	}
	return nil
}


文件: database\model\data_library.go
--------------------------------------------------
package model

import (
	"time"
)

// 提交样本库
type DataLibrary struct {
	ID             string     `gorm:"column:id;primaryKey;type:varchar(32)"`
	UserID         string     `gorm:"column:user_id;type:varchar(32)"`
	SetID          string     `gorm:"column:set_id;type:varchar(32)"`
	IsSet          bool       `gorm:"column:is_set;default:false"`
	ProblemID      string     `gorm:"column:problem_id;type:varchar(32)"`
	SubmitID       string     `gorm:"column:submit_id;type:varchar(32)"`
	SubmitTime     *time.Time `gorm:"column:submit_time"`
	Language       string     `gorm:"column:language;type:varchar(64)"`
	Code           string     `gorm:"column:code;type:longtext"`
	CodeToken      string     `gorm:"column:code_token;type:json"` // 实际使用时可定义为具体的结构体类型
	CodeTokenName  string     `gorm:"column:code_token_name;type:json"`
	CodeTokenTexts string     `gorm:"column:code_token_texts;type:json"`
	CodeLength     int        `gorm:"column:code_length;default:0"`
	AccessCount    int        `gorm:"column:access_count;default:0"`
	Deleted        bool       `gorm:"column:deleted;default:false"`
	CreateTime     *time.Time `gorm:"column:create_time"`
	CreateUser     string     `gorm:"column:create_user;type:varchar(32)"`
	UpdateTime     *time.Time `gorm:"column:update_time"`
	UpdateUser     string     `gorm:"column:update_user;type:varchar(32)"`
}

func (DataLibrary) TableName() string {
	return "data_library"
}


文件: database\model\task_reports.go
--------------------------------------------------
package model

import (
	"time"
)

// 报告库表
type TaskReports struct {
	ID                     string     `gorm:"column:id;primaryKey;type:varchar(32)"`
	ReportType             int        `gorm:"column:report_type;default:0"`
	TaskID                 string     `gorm:"column:task_id;type:varchar(32)"`
	SetID                  string     `gorm:"column:set_id;type:varchar(32)"`
	IsSet                  bool       `gorm:"column:is_set;default:false"`
	ProblemID              string     `gorm:"column:problem_id;type:varchar(32)"`
	SampleCount            int        `gorm:"column:sample_count;default:0"`
	SimilarityGroupCount   int        `gorm:"column:similarity_group_count;default:0"`
	AvgSimilarity          float64    `gorm:"column:avg_similarity;type:decimal(10,2);default:0.00"`
	MaxSimilarity          float64    `gorm:"column:max_similarity;type:decimal(10,2);default:0.00"`
	Threshold              float64    `gorm:"column:threshold;type:decimal(10,2);default:0.50"`
	SimilarityDistribution string     `gorm:"column:similarity_distribution;type:json"`
	DegreeStatistics       string     `gorm:"column:degree_statistics;type:json"`
	CheckMode              int        `gorm:"column:check_mode;default:1"`
	Deleted                bool       `gorm:"column:deleted;default:false"`
	CreateTime             *time.Time `gorm:"column:create_time"`
	CreateUser             string     `gorm:"column:create_user;type:varchar(32)"`
	UpdateTime             *time.Time `gorm:"column:update_time"`
	UpdateUser             string     `gorm:"column:update_user;type:varchar(32)"`
}

func (TaskReports) TableName() string {
	return "task_reports"
}


文件: database\model\task_similarity.go
--------------------------------------------------
package model

import (
	"database/sql"
	"time"
)

type CloneLevel struct {
	CloneLevel     string          `json:"cloneLevel"`
	CloneLevelName string          `json:"cloneLevelName"`
	Similarity     sql.NullFloat64 `json:"similarity"`
	Count          int             `json:"count"`
	Percentage     float64         `json:"percentage"`
}

type TaskReportStats struct {
	SampleCount   int     `json:"sampleCount"`
	GroupCount    int     `json:"groupCount"`
	AvgSimilarity float64 `json:"avgSimilarity"`
	MaxSimilarity float64 `json:"maxSimilarity"`
}

// 检测结果任务库
type TaskSimilarity struct {
	ID               string     `gorm:"column:id;primaryKey;type:varchar(32)"`
	TaskID           string     `gorm:"column:task_id;type:varchar(32)"`
	TaskType         bool       `gorm:"column:task_type;default:false"`
	ProblemID        string     `gorm:"column:problem_id;type:varchar(32)"`
	SetID            string     `gorm:"column:set_id;type:varchar(32)"`
	IsSet            bool       `gorm:"column:is_set;default:false"`
	Language         string     `gorm:"column:language;type:varchar(64)"`
	Similarity       float64    `gorm:"column:similarity;type:decimal(10,2);default:0.00"`
	SubmitUser       string     `gorm:"column:submit_user;type:varchar(32)"`
	SubmitCode       string     `gorm:"column:submit_code;type:longtext"`
	SubmitCodeLength int        `gorm:"column:submit_code_length;default:0"`
	SubmitID         string     `gorm:"column:submit_id;type:varchar(32)"`
	SubmitTime       *time.Time `gorm:"column:submit_time"`
	SubmitCodeToken  string     `gorm:"column:submit_code_token;type:json"`
	SubmitTokenName  string     `gorm:"column:submit_token_name;type:json"`
	SubmitTokenTexts string     `gorm:"column:submit_token_texts;type:json"`
	OriginUser       string     `gorm:"column:origin_user;type:varchar(32)"`
	OriginCode       string     `gorm:"column:origin_code;type:longtext"`
	OriginCodeLength int        `gorm:"column:origin_code_length;default:0"`
	OriginID         string     `gorm:"column:origin_id;type:varchar(32)"`
	OriginTime       *time.Time `gorm:"column:origin_time"`
	OriginCodeToken  string     `gorm:"column:origin_code_token;type:json"`
	OriginTokenName  string     `gorm:"column:origin_token_name;type:json"`
	OriginTokenTexts string     `gorm:"column:origin_token_texts;type:json"`
	Deleted          bool       `gorm:"column:deleted;default:false"`
	CreateTime       *time.Time `gorm:"column:create_time"`
	CreateUser       string     `gorm:"column:create_user;type:varchar(32)"`
	UpdateTime       *time.Time `gorm:"column:update_time"`
	UpdateUser       string     `gorm:"column:update_user;type:varchar(32)"`
}

func (TaskSimilarity) TableName() string {
	return "task_similarity"
}


文件: database\repository\data_library_repository.go
--------------------------------------------------
package repository

import (
	"gorm.io/gorm"
	"similarity-service/internal/database/model"
)

type DataLibraryRepository interface {
	// 操作接口
	GetSimilarityLibraries(isSet bool, problemID, language, userID, setId string, limit int) ([]model.DataLibrary, error)
}

type dataLibraryRepository struct {
	db *gorm.DB
}

func NewDataLibraryRepository(db *gorm.DB) DataLibraryRepository {
	return &dataLibraryRepository{
		db: db,
	}
}

// GetSimilarityLibraries 根据条件查询相似代码库
func (r *dataLibraryRepository) GetSimilarityLibraries(isSet bool, problemID, language, userID, setId string, limit int) ([]model.DataLibrary, error) {
	var dataLibraries []model.DataLibrary

	query := r.db.Model(&model.DataLibrary{}).
		Where("problem_id = ?", problemID).
		Where("language = ?", language).
		Where("user_id != ?", userID).
		Order("update_time DESC").
		Limit(limit)

	if isSet {
		query = query.
			Where("is_set = ?", true).
			Where("set_id = ?", setId)
	} else {
		query = query.
			Where("is_set = ?", false)
	}

	err := query.Find(&dataLibraries).Error
	if err != nil {
		return nil, err
	}

	return dataLibraries, nil
}


文件: database\repository\task_reports_repository.go
--------------------------------------------------
package repository

import (
	"similarity-service/internal/database/model"

	"gorm.io/gorm"
)

type TaskReportsRepository interface {
	// 单个创建
	Create(taskReport *model.TaskReports) error
}

type taskReportsRepository struct {
	db *gorm.DB
}

func NewTaskReportsRepository(db *gorm.DB) TaskReportsRepository {
	return &taskReportsRepository{
		db: db,
	}
}

// Create 单个创建
func (r *taskReportsRepository) Create(taskReport *model.TaskReports) error {
	if taskReport == nil {
		return nil
	}
	return r.db.Create(taskReport).Error
}


文件: database\repository\task_similarity_repository.go
--------------------------------------------------
package repository

import (
	"math"
	"similarity-service/internal/database/model"

	"gorm.io/gorm"
)

type TaskSimilarityRepository interface {
	SelectSimilarityStats(taskID, problemID, setID string, isSet int) (*model.TaskReportStats, error)
	SelectSimilarityDistribution(taskID string) ([]int, error)
	SelectDegreeStatistics(taskID string, threshold float64) ([]model.CloneLevel, error)
	GetDegreeBySimilarity(similarity, threshold float64) (string, error)

	// 批量插入
	BatchCreate(tasks []*model.TaskSimilarity) error
}

type taskSimilarityRepository struct {
	db *gorm.DB
}

func NewTaskSimilarityRepository(db *gorm.DB) TaskSimilarityRepository {
	return &taskSimilarityRepository{
		db: db,
	}
}

// BatchCreate 批量插入
func (r *taskSimilarityRepository) BatchCreate(tasks []*model.TaskSimilarity) error {
	if len(tasks) == 0 {
		return nil
	}
	return r.db.Create(&tasks).Error
}

// SelectSimilarityStats 查询相似度统计
func (r *taskSimilarityRepository) SelectSimilarityStats(taskID, problemID, setID string, isSet int) (*model.TaskReportStats, error) {
	var stats model.TaskReportStats

	query := r.db.Model(&model.TaskSimilarity{})

	if taskID != "" {
		query = query.Where("task_id = ?", taskID)
	}
	if problemID != "" {
		query = query.Where("problem_id = ?", problemID)
	}
	if setID != "" {
		query = query.Where("set_id = ?", setID)
	}

	// 注意：这里根据您的业务逻辑决定是否添加 isSet 条件
	// 如果 isSet 为0表示不筛选，可以省略这个条件
	if isSet != 0 {
		query = query.Where("is_set = ?", isSet)
	}

	err := query.Select("COUNT(*) as sample_count, " +
		"COUNT(DISTINCT similarity) as group_count, " +
		"MAX(similarity) as max_similarity, " +
		"AVG(similarity) as avg_similarity").
		Scan(&stats).Error

	if err != nil {
		return nil, err
	}

	return &stats, nil
}

// SelectSimilarityDistribution 查询相似度分布
func (r *taskSimilarityRepository) SelectSimilarityDistribution(taskID string) ([]int, error) {
	type RangeResult struct {
		RangeIndex int
		Count      int
	}

	var results []RangeResult

	// 使用原生SQL查询
	query := `
		WITH ranges AS (
			SELECT 0 as range_start, 10 as range_end, 1 as range_index
			UNION ALL SELECT 10, 20, 2
			UNION ALL SELECT 20, 30, 3
			UNION ALL SELECT 30, 40, 4
			UNION ALL SELECT 40, 50, 5
			UNION ALL SELECT 50, 60, 6
			UNION ALL SELECT 60, 70, 7
			UNION ALL SELECT 70, 80, 8
			UNION ALL SELECT 80, 90, 9
			UNION ALL SELECT 90, 101, 10
		)
		SELECT r.range_index, COALESCE(COUNT(ts.similarity), 0) as count
		FROM ranges r
		LEFT JOIN task_similarity ts ON ts.task_id = ? 
			AND ts.similarity >= r.range_start / 100.0 
			AND ts.similarity < r.range_end / 100.0
		GROUP BY r.range_index
		ORDER BY r.range_index
	`

	err := r.db.Raw(query, taskID).Scan(&results).Error
	if err != nil {
		return nil, err
	}

	// 转换为数量数组
	counts := make([]int, 10)
	for _, result := range results {
		if result.RangeIndex >= 1 && result.RangeIndex <= 10 {
			counts[result.RangeIndex-1] = result.Count
		}
	}

	return counts, nil
}

//// SelectDegreeStatistics 查询程度统计
//func (r *taskSimilarityRepository) SelectDegreeStatistics(taskID string, threshold float64) ([]model.CloneLevel, error) {
//	var cloneLevels []model.CloneLevel
//
//	query := `
//		WITH degree_categories AS (
//			SELECT 'HIGHLY_SUSPECTED' as degree, 1 as sort_order
//			UNION ALL SELECT 'MEDIUM_SUSPECTED', 2
//			UNION ALL SELECT 'LOW_SUSPECTED', 3
//			UNION ALL SELECT 'NOT_REACHED', 4
//		),
//		degree_stats AS (
//			SELECT
//				CASE
//					WHEN similarity >= ? * 0.9 THEN 'HIGHLY_SUSPECTED'
//					WHEN similarity >= ? * 0.7 THEN 'MEDIUM_SUSPECTED'
//					WHEN similarity >= ? * 0.5 THEN 'LOW_SUSPECTED'
//					WHEN similarity >= ? THEN 'NOT_REACHED'
//					ELSE 'NOT_DETECTED'
//				END as degree,
//				COUNT(*) as count
//			FROM task_similarity
//			WHERE task_id = ?
//			GROUP BY
//				CASE
//					WHEN similarity >= ? * 0.9 THEN 'HIGHLY_SUSPECTED'
//					WHEN similarity >= ? * 0.7 THEN 'MEDIUM_SUSPECTED'
//					WHEN similarity >= ? * 0.5 THEN 'LOW_SUSPECTED'
//					WHEN similarity >= ? THEN 'NOT_REACHED'
//					ELSE 'NOT_DETECTED'
//				END
//		),
//		total_stats AS (
//			SELECT COUNT(*) as total_count
//			FROM task_similarity
//			WHERE task_id = ?
//		)
//		SELECT
//			dc.degree as clone_level,
//			CASE dc.degree
//				WHEN 'HIGHLY_SUSPECTED' THEN '高度可疑'
//				WHEN 'MEDIUM_SUSPECTED' THEN '中度可疑'
//				WHEN 'LOW_SUSPECTED' THEN '轻度可疑'
//				WHEN 'NOT_REACHED' THEN '未达阈值'
//			END as clone_level_name,
//			NULL as similarity,
//			COALESCE(ds.count, 0) as count,
//			CASE
//				WHEN ts.total_count > 0 THEN
//					ROUND((COALESCE(ds.count, 0) * 100.0 / ts.total_count), 2)
//				ELSE 0
//			END as percentage
//		FROM degree_categories dc
//		LEFT JOIN degree_stats ds ON dc.degree = ds.degree
//		CROSS JOIN total_stats ts
//		ORDER BY dc.sort_order
//	`
//
//	err := r.db.Raw(query,
//		threshold, threshold, threshold, threshold, taskID,
//		threshold, threshold, threshold, threshold, taskID).Scan(&cloneLevels).Error
//
//	if err != nil {
//		return nil, err
//	}
//
//	return cloneLevels, nil
//}

// SelectDegreeStatistics 查询程度统计
func (r *taskSimilarityRepository) SelectDegreeStatistics(taskID string, threshold float64) ([]model.CloneLevel, error) {
	var cloneLevels []model.CloneLevel

	// 首先获取总记录数
	var totalCount int64
	err := r.db.Model(&model.TaskSimilarity{}).
		Where("task_id = ?", taskID).
		Count(&totalCount).Error
	if err != nil {
		return nil, err
	}

	// 定义程度分类
	degreeCategories := []struct {
		degree     string
		name       string
		sortOrder  int
		minPercent float64
		maxPercent float64
	}{
		{"HIGHLY_SUSPECTED", "高度可疑", 1, 0.9, 1.0},
		{"MEDIUM_SUSPECTED", "中度可疑", 2, 0.7, 0.9},
		{"LOW_SUSPECTED", "轻度可疑", 3, 0.5, 0.7},
		{"NOT_REACHED", "未达阈值", 4, 1.0, 1.0}, // 特殊处理
	}

	// 查询每个程度的数量
	for _, category := range degreeCategories {
		var count int64
		var query *gorm.DB

		if category.degree == "NOT_REACHED" {
			// NOT_REACHED 特殊处理：>= threshold 但 < threshold * 0.5
			query = r.db.Model(&model.TaskSimilarity{}).
				Where("task_id = ? AND similarity >= ? AND similarity < ?",
					taskID, threshold, threshold*0.5)
		} else {
			// 其他程度
			query = r.db.Model(&model.TaskSimilarity{}).
				Where("task_id = ? AND similarity >= ? AND similarity < ?",
					taskID, threshold*category.minPercent, threshold*category.maxPercent)
		}

		err := query.Count(&count).Error
		if err != nil {
			return nil, err
		}

		// 计算百分比
		percentage := 0.0
		if totalCount > 0 {
			percentage = float64(count) * 100.0 / float64(totalCount)
			percentage = math.Round(percentage*100) / 100 // 保留2位小数
		}

		cloneLevels = append(cloneLevels, model.CloneLevel{
			CloneLevel:     category.degree,
			CloneLevelName: category.name,
			Count:          int(count),
			Percentage:     percentage,
		})
	}

	return cloneLevels, nil
}

// GetDegreeBySimilarity 根据相似度获取程度
func (r *taskSimilarityRepository) GetDegreeBySimilarity(similarity, threshold float64) (string, error) {
	var degree string

	query := `
		SELECT CASE
			WHEN ? >= ? * 0.9 THEN 'HIGHLY_SUSPECTED'
			WHEN ? >= ? * 0.7 THEN 'MEDIUM_SUSPECTED'
			WHEN ? >= ? * 0.5 THEN 'LOW_SUSPECTED'
			WHEN ? >= ? THEN 'NOT_REACHED'
			ELSE 'NOT_DETECTED'
		END as degree
	`

	err := r.db.Raw(query,
		similarity, threshold,
		similarity, threshold,
		similarity, threshold,
		similarity, threshold).Scan(&degree).Error

	if err != nil {
		return "", err
	}

	return degree, nil
}


文件: initializer\manager.go
--------------------------------------------------
package initializer

import (
	"fmt"
	"similarity-service/internal/config"
	"similarity-service/internal/database"
	repository2 "similarity-service/internal/database/repository"
	"similarity-service/internal/mq"
	"similarity-service/internal/nacos"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
)

type InitializerManager struct {
	config                   config.Config
	mysqlManager             *database.MySQLManager
	rabbitMQManager          *mq.RabbitMQManager
	serviceRegistry          *nacos.ServiceRegistryManager
	dataLibraryRepository    repository2.DataLibraryRepository
	taskSimilarityRepository repository2.TaskSimilarityRepository
	taskReportsRepository    repository2.TaskReportsRepository
}

func NewInitializerManager(c config.Config) *InitializerManager {
	return &InitializerManager{
		config: c,
	}
}

func (im *InitializerManager) Initialize() error {
	// 初始化 RabbitMQ（同步，因为其他组件依赖它）
	if err := im.initRabbitMQ(); err != nil {
		return err
	}

	// 初始化服务注册（同步）
	im.initServiceRegistry()

	// 异步初始化 MySQL
	go im.initMySQLWithRetry()

	return nil
}

func (im *InitializerManager) initRabbitMQ() error {
	rabbitMQManager, err := mq.NewRabbitMQManager(im.config.RabbitMQ)
	if err != nil {
		logx.Errorf("无法连接到 RabbitMQ: %v", err)
		return err
	}
	im.rabbitMQManager = rabbitMQManager
	return nil
}

func (im *InitializerManager) initServiceRegistry() {
	im.serviceRegistry = nacos.NewServiceRegistryManager(im.config.Nacos, im.config)
	if err := im.serviceRegistry.Register(); err != nil {
		logx.Errorf("服务注册初始化失败: %v", err)
	}
}

func (im *InitializerManager) initMySQLWithRetry() {
	maxRetries := 5
	retryInterval := time.Second * 5

	for i := 0; i < maxRetries; i++ {
		mysqlManager, err := database.NewMySQLManager(im.config.MySQL)
		if err != nil {
			logx.Errorf("初始化 MySQL 失败 (尝试 %d/%d): %v", i+1, maxRetries, err)

			if i == maxRetries-1 {
				logx.Error("已达到最大重试次数，MySQL 连接失败")
				return
			}

			logx.Infof("%v 后重试...", retryInterval)
			time.Sleep(retryInterval)
			continue
		}

		im.mysqlManager = mysqlManager
		im.dataLibraryRepository = repository2.NewDataLibraryRepository(mysqlManager.DB)
		im.taskSimilarityRepository = repository2.NewTaskSimilarityRepository(mysqlManager.DB)
		im.taskReportsRepository = repository2.NewTaskReportsRepository(mysqlManager.DB)
		logx.Info("MySQL 连接成功")
		return
	}
}

func (im *InitializerManager) Close() error {
	var errs []error

	if im.serviceRegistry != nil {
		if err := im.serviceRegistry.Deregister(); err != nil {
			errs = append(errs, err)
		}
	}

	if im.rabbitMQManager != nil {
		if err := im.rabbitMQManager.Close(); err != nil {
			errs = append(errs, err)
		}
	}

	if im.mysqlManager != nil {
		if err := im.mysqlManager.Close(); err != nil {
			errs = append(errs, err)
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("关闭资源时发生错误: %v", errs)
	}
	return nil
}

// Getters
func (im *InitializerManager) GetMySQLManager() *database.MySQLManager {
	return im.mysqlManager
}

func (im *InitializerManager) GetRabbitMQManager() *mq.RabbitMQManager {
	return im.rabbitMQManager
}

func (im *InitializerManager) GetDataLibraryRepo() repository2.DataLibraryRepository {
	return im.dataLibraryRepository
}

func (im *InitializerManager) GetTaskSimilarityRepo() repository2.TaskSimilarityRepository {
	return im.taskSimilarityRepository
}

func (im *InitializerManager) GetTaskReportsRepo() repository2.TaskReportsRepository {
	return im.taskReportsRepository
}

func (im *InitializerManager) GetServiceReRegistry() *nacos.ServiceRegistryManager {
	return im.serviceRegistry
}

func (im *InitializerManager) IsDBReady() bool {
	return im.mysqlManager != nil && im.mysqlManager.IsReady()
}


文件: logic\common.go
--------------------------------------------------
package logic

import (
	"context"
	"encoding/json"
	"similarity-service/internal/core"
	"similarity-service/internal/mq"
	"similarity-service/internal/svc"
	"sync"
	"time"

	"github.com/streadway/amqp"
	"github.com/zeromicro/go-zero/core/logx"
)

type CommonLogic struct {
	ctx       context.Context
	svcCtx    *svc.ServiceContext
	semaphore chan struct{} // 控制并发数量的信号量
}

func NewCommonLogic(ctx context.Context, svcCtx *svc.ServiceContext) *CommonLogic {
	return &CommonLogic{
		ctx:       ctx,
		svcCtx:    svcCtx,
		semaphore: make(chan struct{}, 20), // 控制并发数量
	}
}

func (l *CommonLogic) StartConsumer() {
	CommonChannel := l.svcCtx.Initializer.GetRabbitMQManager().CommonChannel

	_, err := CommonChannel.QueueDeclare(
		l.svcCtx.Config.RabbitMQ.Common.SimilarityQueue,
		true, false, false, false, nil,
	)
	if err != nil {
		logx.Errorf("无法声明问题队列: %v", err)
		return
	}

	// 增加预取计数，提高并发度
	err = CommonChannel.Qos(
		50, // 增加预取计数
		0,
		false,
	)
	if err != nil {
		logx.Errorf("设置Qos失败: %v", err)
		return
	}

	msgs, err := CommonChannel.Consume(
		l.svcCtx.Config.RabbitMQ.Common.SimilarityQueue,
		"", false, false, false, false, nil,
	)
	if err != nil {
		logx.Errorf("注册相似消费者失败: %v", err)
		return
	}

	logx.Info("相似消费者已成功启动")

	var wg sync.WaitGroup

	for d := range msgs {
		wg.Add(1)
		l.semaphore <- struct{}{} // 获取信号量

		go func(delivery amqp.Delivery) {
			defer wg.Done()
			defer func() { <-l.semaphore }() // 释放信号量

			l.processMessage(delivery)
		}(d)
	}

	wg.Wait()
}

// 为每个消息创建独立的上下文，避免上下文取消影响其他处理
func (l *CommonLogic) processMessage(delivery amqp.Delivery) {
	// 为每个消息创建独立的上下文
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	defer func() {
		if err := delivery.Ack(false); err != nil {
			logx.Errorf("未能确认相似消息: %v", err)
		}
	}()

	var similarityMessage mq.SimilarityMessage
	if err := json.Unmarshal(delivery.Body, &similarityMessage); err != nil {
		logx.Errorf("解码 JSON 出错: %v", err)
		return
	}

	// 使用新的上下文创建工作空间
	workspace, result := core.NewWorkspace(ctx, l.svcCtx.Config, similarityMessage, l.svcCtx)
	if result != nil {
		if err := l.sendResultToMQ(result); err != nil {
			logx.Errorf("发送结果到MQ失败: %v", err)
		}
		return
	}

	// 程序执行
	resultMessage := workspace.Execute()

	// 发送结果
	if err := l.sendResultToMQ(resultMessage); err != nil {
		logx.Errorf("发送结果到MQ失败: %v", err)
	}
}

func (l *CommonLogic) sendResultToMQ(result *mq.SimilarityResultMessage) error {
	body, err := json.Marshal(result)
	if err != nil {
		return err
	}

	exchange := l.svcCtx.Config.RabbitMQ.Common.ResultExchange
	routingKey := l.svcCtx.Config.RabbitMQ.Common.ResultRoutingKey

	return l.svcCtx.Initializer.GetRabbitMQManager().CommonChannel.Publish(
		exchange,
		routingKey,
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        body,
			Timestamp:   time.Now(),
		},
	)
}


文件: logic\consume.go
--------------------------------------------------
package logic

import (
	"context"
	"similarity-service/internal/svc"
)

type ConsumeLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewConsumeLogic(ctx context.Context, svcCtx *svc.ServiceContext) *ConsumeLogic {
	return &ConsumeLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *ConsumeLogic) StartConsuming() {
	ctx, cancel := context.WithCancel(l.ctx)
	defer cancel()

	go NewCommonLogic(ctx, l.svcCtx).StartConsumer()

	<-ctx.Done()
}


文件: mq\rabbitmq.go
--------------------------------------------------
package mq

import (
	"fmt"
	"similarity-service/internal/config"

	"github.com/streadway/amqp"
	"github.com/zeromicro/go-zero/core/logx"
)

type RabbitMQManager struct {
	Conn          *amqp.Connection
	CommonChannel *amqp.Channel
	config        config.RabbitMQConfig
}

func NewRabbitMQManager(c config.RabbitMQConfig) (*RabbitMQManager, error) {
	conn, err := amqp.DialConfig(c.Host, amqp.Config{
		Vhost: c.VirtualHost,
	})
	if err != nil {
		return nil, err
	}

	commonCh, err := conn.Channel()
	if err != nil {
		conn.Close()
		return nil, err
	}

	logx.Info("RabbitMQ 连接成功")
	return &RabbitMQManager{
		Conn:          conn,
		CommonChannel: commonCh,
		config:        c,
	}, nil
}

func (r *RabbitMQManager) IsReady() bool {
	return r.Conn != nil && !r.Conn.IsClosed()
}

func (r *RabbitMQManager) Close() error {
	if r.CommonChannel != nil {
		r.CommonChannel.Close()
	}
	if r.Conn != nil {
		return r.Conn.Close()
	}
	return nil
}

func (r *RabbitMQManager) GetChannel() (*amqp.Channel, error) {
	if !r.IsReady() {
		return nil, fmt.Errorf("RabbitMQ 连接不可用")
	}
	return r.Conn.Channel()
}


文件: mq\similarity_request.go
--------------------------------------------------
package mq

type SimilarityMessage struct {
	TaskID         string   `json:"taskId"`         // 任务ID
	SubmitID       string   `json:"submitId"`       // 提交ID
	SetID          string   `json:"setId"`          // 题集
	ProblemID      string   `json:"problemId"`      // 多个或单个题目
	UserID         string   `json:"userId"`         // 多个或单个题目
	IsSet          bool     `json:"isSet"`          // 是否是题集
	Language       string   `json:"language"`       // 语言
	MinMatchLength int      `json:"minMatchLength"` // 敏感度
	Threshold      float64  `json:"threshold"`      // 阈值
	TaskType       bool     `json:"taskType"`       // 是否手动
	Code           string   `json:"code"`
	CodeLength     int      `json:"codeLength"`
	CodeTokens     []int    `json:"codeTokens"`
	CodeTokenNames []string `json:"codeTokenNames"`
	CodeTokenTexts []string `json:"codeTokenTexts"`
}


文件: mq\similarity_response.go
--------------------------------------------------
package mq

type SimilarityResultMessage struct {
	TaskID         string   `json:"taskId"`         // 任务ID
	SubmitID       string   `json:"submitId"`       // 提交ID
	SetID          string   `json:"setId"`          // 题集
	ProblemID      string   `json:"problemId"`      // 多个或单个题目
	IsSet          bool     `json:"isSet"`          // 是否是题集
	UserID         string   `json:"userId"`         // 多个或单个题目
	Language       string   `json:"language"`       // 语言
	MinMatchLength int      `json:"minMatchLength"` // 敏感度
	Threshold      float64  `json:"threshold"`      // 阈值
	TaskType       bool     `json:"taskType"`       // 是否手动
	Code           string   `json:"code"`
	CodeLength     int      `json:"codeLength"`
	CodeTokens     []int    `json:"codeTokens"`
	CodeTokenNames []string `json:"codeTokenNames"`
	CodeTokenTexts []string `json:"codeTokenTexts"`
	Similarity     float64  `json:"similarity"` // 相似度
	ReportID       string   `json:"reportId"`
	Skip           bool     `json:"skip"`
}


文件: nacos\nacos.go
--------------------------------------------------
package nacos

import (
	"fmt"
	"strings"

	"github.com/nacos-group/nacos-sdk-go/v2/clients"
	"github.com/nacos-group/nacos-sdk-go/v2/clients/config_client"
	"github.com/nacos-group/nacos-sdk-go/v2/common/constant"
	"github.com/nacos-group/nacos-sdk-go/v2/vo"
	"github.com/zeromicro/go-zero/core/logx"
)

type ConfigManager struct {
	client config_client.IConfigClient
	group  string
}

func NewNacosConfigManager(serverAddr, username, password, namespace, group string) (*ConfigManager, error) {
	if serverAddr == "" {
		return nil, fmt.Errorf("Nacos服务器地址不能为空")
	}

	// 解析服务器地址，处理端口
	serverConfigs, err := parseServerConfigs(serverAddr)
	if err != nil {
		return nil, err
	}

	// 创建 clientConfig
	clientConfig := constant.ClientConfig{
		NamespaceId:         namespace,
		TimeoutMs:           10000, // 增加超时时间
		NotLoadCacheAtStart: true,
		LogDir:              "/tmp/nacos/log",
		CacheDir:            "/tmp/nacos/cache",
		LogLevel:            "error", // 降低日志级别
		Username:            username,
		Password:            password,
	}

	// 如果用户名和密码都为空，则不设置认证
	if username == "" && password == "" {
		clientConfig.Username = ""
		clientConfig.Password = ""
	}

	// 创建配置客户端
	configClient, err := clients.NewConfigClient(
		vo.NacosClientParam{
			ClientConfig:  &clientConfig,
			ServerConfigs: serverConfigs,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("创建Nacos配置客户端失败: %v", err)
	}

	return &ConfigManager{
		client: configClient,
		group:  group,
	}, nil
}

// parseServerConfigs 解析服务器地址
func parseServerConfigs(serverAddr string) ([]constant.ServerConfig, error) {
	var serverConfigs []constant.ServerConfig

	// 支持多个服务器地址（逗号分隔）
	addrs := strings.Split(serverAddr, ",")
	for _, addr := range addrs {
		addr = strings.TrimSpace(addr)
		if addr == "" {
			continue
		}

		// 解析主机和端口
		var host string
		var port uint64 = 8848 // 默认端口

		if strings.Contains(addr, ":") {
			parts := strings.Split(addr, ":")
			if len(parts) != 2 {
				return nil, fmt.Errorf("服务器地址格式无效: %s", addr)
			}
			host = parts[0]
			// 这里可以解析端口，但 Nacos SDK 通常使用默认端口
			// portStr := parts[1]
			// 如果需要自定义端口，可以在这里解析
		} else {
			host = addr
		}

		serverConfigs = append(serverConfigs, constant.ServerConfig{
			IpAddr:      host,
			Port:        port,
			ContextPath: "/nacos",
			Scheme:      "http", // 明确指定协议
		})
	}

	if len(serverConfigs) == 0 {
		return nil, fmt.Errorf("未找到有效的服务器地址")
	}

	return serverConfigs, nil
}

// GetConfig 从 Nacos 获取配置
func (m *ConfigManager) GetConfig(dataId string) (string, error) {
	if dataId == "" {
		return "", fmt.Errorf("dataId不能为空")
	}

	content, err := m.client.GetConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
	})
	if err != nil {
		return "", fmt.Errorf("从Nacos获取配置失败: %v", err)
	}

	if content == "" {
		return "", fmt.Errorf("配置内容为空, dataId: %s, group: %s", dataId, m.group)
	}

	return content, nil
}

// CheckConfigExists 检查配置是否存在
func (m *ConfigManager) CheckConfigExists(dataId string) (bool, error) {
	content, err := m.client.GetConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
	})
	if err != nil {
		return false, err
	}
	return content != "", nil
}

func (m *ConfigManager) ListenConfig(dataId string, onConfigChange func(string)) error {
	err := m.client.ListenConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
		OnChange: func(namespace, group, dataId, data string) {
			logx.Infof("配置已更新：命名空间=%s，组别=%s，数据ID=%s", namespace, group, dataId)
			onConfigChange(data)
		},
	})
	if err != nil {
		return fmt.Errorf("监听配置失败: %v", err)
	}
	logx.Infof("开始监听配置变更，数据ID：%s，组别：%s", dataId, m.group)
	return nil
}

// CancelListenConfig 取消监听配置
func (m *ConfigManager) CancelListenConfig(dataId string) error {
	err := m.client.CancelListenConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
	})
	if err != nil {
		return fmt.Errorf("取消监听配置失败: %v", err)
	}
	logx.Infof("已取消监听配置变更，数据ID：%s，组别：%s", dataId, m.group)
	return nil
}


文件: nacos\registry.go
--------------------------------------------------
package nacos

import (
	"fmt"
	"net"
	"similarity-service/internal/config"
	"strconv"
	"time"

	"github.com/nacos-group/nacos-sdk-go/v2/clients"
	"github.com/nacos-group/nacos-sdk-go/v2/clients/naming_client"
	"github.com/nacos-group/nacos-sdk-go/v2/common/constant"
	"github.com/nacos-group/nacos-sdk-go/v2/model"
	"github.com/nacos-group/nacos-sdk-go/v2/vo"
	"github.com/zeromicro/go-zero/core/logx"
)

// ServiceInstance 服务实例信息
type ServiceInstance struct {
	InstanceId  string            `json:"instanceId"`
	Ip          string            `json:"ip"`
	Port        uint64            `json:"port"`
	ServiceName string            `json:"serviceName"`
	Weight      float64           `json:"weight"`
	Healthy     bool              `json:"healthy"`
	Enabled     bool              `json:"enabled"`
	Metadata    map[string]string `json:"metadata"`
	ClusterName string            `json:"clusterName"`
}

// ServiceRegistry 服务注册器
type ServiceRegistry struct {
	client      naming_client.INamingClient
	group       string
	serviceName string
	ip          string
	port        uint64
	metadata    map[string]string
	clusterName string
	instanceId  string
}

// NewServiceRegistry 创建服务注册器
func NewServiceRegistry(nacosConfig config.NacosConfig, serviceConfig config.Config) (*ServiceRegistry, error) {
	if nacosConfig.ServerAddr == "" {
		return nil, fmt.Errorf("Nacos服务器地址不能为空")
	}

	// 解析服务器地址
	serverConfigs, err := parseServerConfigs(nacosConfig.ServerAddr)
	if err != nil {
		return nil, err
	}

	// 创建 clientConfig
	clientConfig := constant.ClientConfig{
		NamespaceId:         nacosConfig.Namespace,
		TimeoutMs:           10000,
		NotLoadCacheAtStart: true,
		LogDir:              "/tmp/nacos/log",
		CacheDir:            "/tmp/nacos/cache",
		LogLevel:            "error",
		Username:            nacosConfig.Username,
		Password:            nacosConfig.Password,
	}

	// 如果用户名和密码都为空，则不设置认证
	if nacosConfig.Username == "" && nacosConfig.Password == "" {
		clientConfig.Username = ""
		clientConfig.Password = ""
	}

	// 创建命名客户端
	namingClient, err := clients.NewNamingClient(
		vo.NacosClientParam{
			ClientConfig:  &clientConfig,
			ServerConfigs: serverConfigs,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("创建Nacos命名客户端失败: %v", err)
	}

	// 解析服务端口
	port, err := strconv.ParseUint(strconv.Itoa(serviceConfig.Port), 10, 64)
	if err != nil {
		return nil, fmt.Errorf("端口号无效: %v", err)
	}

	// 获取自动检测的IP
	autoIP, err := getLocalIP()
	if err != nil {
		logx.Errorf("自动获取IP失败: %v，使用默认配置", err)
		autoIP = "0.0.0.0"
	}

	// 确定最终使用的IP
	finalIP := autoIP
	if serviceConfig.Host != "0.0.0.0" && serviceConfig.Host != "" {
		finalIP = serviceConfig.Host
		logx.Infof("使用配置的IP: %s (自动检测的IP: %s)", finalIP, autoIP)
	} else {
		logx.Infof("使用自动检测的IP: %s", finalIP)
	}

	logx.Infof("服务注册 IP: %s", finalIP)

	// 生成实例ID
	instanceId := fmt.Sprintf("%s-%s-%d", serviceConfig.Name, finalIP, port)

	return &ServiceRegistry{
		client:      namingClient,
		group:       nacosConfig.Group,
		serviceName: serviceConfig.Name,
		ip:          finalIP,
		port:        port,
		metadata: map[string]string{
			"version":   "1.0.0",
			"port":      strconv.Itoa(serviceConfig.Port),
			"startTime": time.Now().Format(time.RFC3339),
		},
		clusterName: "DEFAULT",
		instanceId:  instanceId,
	}, nil
}

// 获取本机第一个非回环的IPv4地址
func getLocalIP() (string, error) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return "", err
	}

	for _, addr := range addrs {
		if ipNet, ok := addr.(*net.IPNet); ok && !ipNet.IP.IsLoopback() {
			if ipNet.IP.To4() != nil {
				return ipNet.IP.String(), nil
			}
		}
	}
	return "", fmt.Errorf("不能获取 IP 地址")
}

// Register 注册服务
func (r *ServiceRegistry) Register() error {
	param := vo.RegisterInstanceParam{
		Ip:          r.ip,
		Port:        r.port,
		ServiceName: r.serviceName,
		Weight:      10,
		Enable:      true,
		Healthy:     true,
		Ephemeral:   true,
		Metadata:    r.metadata,
		ClusterName: r.clusterName,
		GroupName:   r.group,
	}

	success, err := r.client.RegisterInstance(param)
	if err != nil {
		return fmt.Errorf("服务注册失败: %v", err)
	}

	if !success {
		return fmt.Errorf("服务注册未成功")
	}

	logx.Infof("服务注册成功: %s:%d, 实例ID: %s", r.ip, r.port, r.instanceId)
	return nil
}

// Deregister 注销服务
func (r *ServiceRegistry) Deregister() error {
	param := vo.DeregisterInstanceParam{
		Ip:          r.ip,
		Port:        r.port,
		ServiceName: r.serviceName,
		Cluster:     r.clusterName,
		GroupName:   r.group,
		Ephemeral:   true,
	}

	success, err := r.client.DeregisterInstance(param)
	if err != nil {
		return fmt.Errorf("服务注销失败: %v", err)
	}

	if !success {
		return fmt.Errorf("服务注销未成功")
	}

	logx.Infof("服务注销成功: %s:%d", r.ip, r.port)
	return nil
}

// SetMetadata 设置元数据
func (r *ServiceRegistry) SetMetadata(key, value string) {
	r.metadata[key] = value
}

// GetServiceInstances 获取服务实例列表
func (r *ServiceRegistry) GetServiceInstances(serviceName string) ([]ServiceInstance, error) {
	instances, err := r.client.SelectInstances(vo.SelectInstancesParam{
		ServiceName: serviceName,
		GroupName:   r.group,
		Clusters:    []string{r.clusterName},
		HealthyOnly: true,
	})
	if err != nil {
		return nil, fmt.Errorf("获取服务实例列表失败: %v", err)
	}

	var result []ServiceInstance
	for _, instance := range instances {
		result = append(result, ServiceInstance{
			InstanceId:  instance.InstanceId,
			Ip:          instance.Ip,
			Port:        instance.Port,
			ServiceName: instance.ServiceName,
			Weight:      instance.Weight,
			Healthy:     instance.Healthy,
			Enabled:     instance.Enable,
			Metadata:    instance.Metadata,
			ClusterName: instance.ClusterName,
		})
	}
	return result, nil
}

// Subscribe 订阅服务变化
func (r *ServiceRegistry) Subscribe(serviceName string, callback func([]ServiceInstance)) error {
	err := r.client.Subscribe(&vo.SubscribeParam{
		ServiceName: serviceName,
		GroupName:   r.group,
		Clusters:    []string{r.clusterName},
		SubscribeCallback: func(services []model.Instance, err error) {
			if err != nil {
				logx.Errorf("服务订阅回调错误: %v", err)
				return
			}

			var instances []ServiceInstance
			for _, service := range services {
				instances = append(instances, ServiceInstance{
					InstanceId:  service.InstanceId,
					Ip:          service.Ip,
					Port:        service.Port,
					ServiceName: service.ServiceName,
					Weight:      service.Weight,
					Healthy:     service.Healthy,
					Enabled:     service.Enable,
					Metadata:    service.Metadata,
					ClusterName: service.ClusterName,
				})
			}
			callback(instances)
		},
	})
	if err != nil {
		return fmt.Errorf("服务订阅失败: %v", err)
	}
	return nil
}

// Unsubscribe 取消订阅
func (r *ServiceRegistry) Unsubscribe(serviceName string) error {
	err := r.client.Unsubscribe(&vo.SubscribeParam{
		ServiceName: serviceName,
		GroupName:   r.group,
		Clusters:    []string{r.clusterName},
	})
	if err != nil {
		return fmt.Errorf("取消服务订阅失败: %v", err)
	}
	return nil
}

// HealthCheck 健康检查
func (r *ServiceRegistry) HealthCheck() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		// 发送心跳，更新服务状态
		_, err := r.client.GetService(vo.GetServiceParam{
			ServiceName: r.serviceName,
			GroupName:   r.group,
		})
		if err != nil {
			logx.Errorf("健康检查失败: %v", err)
			// 尝试重新注册
			if err := r.Register(); err != nil {
				logx.Errorf("健康检查失败后重新注册服务失败: %v", err)
			} else {
				logx.Info("健康检查失败后服务重新注册成功")
			}
		} else {
			logx.Debugf("服务健康检查通过: %s", r.serviceName)
		}
	}
}

// GetServiceInfo 获取服务信息
func (r *ServiceRegistry) GetServiceInfo() ServiceInstance {
	return ServiceInstance{
		InstanceId:  r.instanceId,
		Ip:          r.ip,
		Port:        r.port,
		ServiceName: r.serviceName,
		Weight:      10,
		Healthy:     true,
		Enabled:     true,
		Metadata:    r.metadata,
		ClusterName: r.clusterName,
	}
}


文件: nacos\service_registry.go
--------------------------------------------------
package nacos

import (
	"similarity-service/internal/config"

	"github.com/zeromicro/go-zero/core/logx"
)

type ServiceRegistryManager struct {
	registry *ServiceRegistry
	enabled  bool
}

func NewServiceRegistryManager(nacosConfig config.NacosConfig, appConfig config.Config) *ServiceRegistryManager {
	if nacosConfig.ServerAddr == "" {
		return &ServiceRegistryManager{enabled: false}
	}

	registry, err := NewServiceRegistry(nacosConfig, appConfig)
	if err != nil {
		logx.Errorf("创建服务注册器失败: %v", err)
		return &ServiceRegistryManager{enabled: false}
	}

	return &ServiceRegistryManager{
		registry: registry,
		enabled:  true,
	}
}

func (s *ServiceRegistryManager) Register() error {
	if !s.enabled || s.registry == nil {
		return nil
	}

	if err := s.registry.Register(); err != nil {
		logx.Errorf("服务注册失败: %v", err)
		return err
	}

	logx.Info("服务成功注册到 Nacos")

	// 启动健康检查
	go s.registry.HealthCheck()

	return nil
}

func (s *ServiceRegistryManager) Deregister() error {
	if !s.enabled || s.registry == nil {
		return nil
	}
	return s.registry.Deregister()
}

func (s *ServiceRegistryManager) IsEnabled() bool {
	return s.enabled
}


文件: similarity\similarity.go
--------------------------------------------------
package similarity

// MatchTile 表示匹配的区块
type MatchTile struct {
	Start1 int
	Start2 int
	Length int
}

// GreedyStringTiling 优化后的贪婪字符串匹配算法
func GreedyStringTiling(token1, token2 []int, minMatchLength int) int {
	if len(token1) == 0 || len(token2) == 0 {
		return 0
	}

	matched1 := make([]bool, len(token1))
	matched2 := make([]bool, len(token2))
	var tiles []MatchTile

	maxMatch := minMatchLength

	for {
		maxMatch = minMatchLength
		var maxTiles []MatchTile

		// 使用更高效的方式寻找最大匹配块
		findMaxMatches(token1, token2, matched1, matched2, minMatchLength, &maxMatch, &maxTiles)

		if maxMatch <= minMatchLength {
			break
		}

		// 标记已匹配的块
		for _, tile := range maxTiles {
			for k := 0; k < tile.Length; k++ {
				matched1[tile.Start1+k] = true
				matched2[tile.Start2+k] = true
			}
			tiles = append(tiles, tile)
		}
	}

	// 计算总匹配数
	totalMatches := 0
	for _, tile := range tiles {
		totalMatches += tile.Length
	}

	return totalMatches
}

// findMaxMatches 优化后的最大匹配查找
func findMaxMatches(token1, token2 []int, matched1, matched2 []bool,
	minMatchLength int, maxMatch *int, maxTiles *[]MatchTile) {

	n1, n2 := len(token1), len(token2)

	// 预计算可匹配的起始位置
	availableStarts1 := getAvailableStarts(matched1, n1)
	availableStarts2 := getAvailableStarts(matched2, n2)

	// 使用更智能的搜索策略
	for _, i := range availableStarts1 {
		if matched1[i] {
			continue
		}

		// 提前终止检查
		if n1-i < *maxMatch {
			continue
		}

		for _, j := range availableStarts2 {
			if matched2[j] {
				continue
			}

			// 提前终止检查
			if n2-j < *maxMatch {
				continue
			}

			// 快速检查前maxMatch个字符是否可能匹配
			if !quickCheck(token1, token2, i, j, *maxMatch) {
				continue
			}

			// 计算实际匹配长度
			k := computeMatchLength(token1, token2, matched1, matched2, i, j, n1, n2)

			if k > *maxMatch {
				*maxMatch = k
				*maxTiles = (*maxTiles)[:0] // 清空切片
				*maxTiles = append(*maxTiles, MatchTile{i, j, k})
			} else if k == *maxMatch && k > minMatchLength {
				*maxTiles = append(*maxTiles, MatchTile{i, j, k})
			}
		}
	}
}

// getAvailableStarts 获取可用的起始位置
func getAvailableStarts(matched []bool, length int) []int {
	var starts []int
	for i := 0; i < length; i++ {
		if !matched[i] {
			starts = append(starts, i)
		}
	}
	return starts
}

// quickCheck 快速检查前n个字符是否可能匹配
func quickCheck(token1, token2 []int, i, j, n int) bool {
	if i+n > len(token1) || j+n > len(token2) {
		return false
	}

	// 检查前n个字符
	for k := 0; k < n; k++ {
		if token1[i+k] != token2[j+k] {
			return false
		}
	}
	return true
}

// computeMatchLength 计算匹配长度
func computeMatchLength(token1, token2 []int, matched1, matched2 []bool,
	i, j, n1, n2 int) int {

	k := 0
	for i+k < n1 && j+k < n2 {
		if matched1[i+k] || matched2[j+k] {
			break
		}
		if token1[i+k] != token2[j+k] {
			break
		}
		k++
	}
	return k
}

// GreedyStringTilingOptimized 进一步优化的版本，使用更少的内存分配
func GreedyStringTilingOptimized(token1, token2 []int, minMatchLength int) int {
	if len(token1) == 0 || len(token2) == 0 {
		return 0
	}

	n1, n2 := len(token1), len(token2)
	matched1 := make([]bool, n1)
	matched2 := make([]bool, n2)

	totalMatches := 0
	maxMatch := minMatchLength

	// 预分配切片以避免重复分配
	maxTiles := make([]MatchTile, 0, min(n1, n2)/minMatchLength+1)

	for {
		maxMatch = minMatchLength
		maxTiles = maxTiles[:0] // 重用切片

		// 优化的匹配查找
		findMaxMatchesOptimized(token1, token2, matched1, matched2,
			minMatchLength, &maxMatch, &maxTiles)

		if maxMatch <= minMatchLength {
			break
		}

		// 标记匹配并计数
		for _, tile := range maxTiles {
			for k := 0; k < tile.Length; k++ {
				matched1[tile.Start1+k] = true
				matched2[tile.Start2+k] = true
			}
			totalMatches += tile.Length
		}
	}

	return totalMatches
}

// findMaxMatchesOptimized 进一步优化的匹配查找
func findMaxMatchesOptimized(token1, token2 []int, matched1, matched2 []bool,
	minMatchLength int, maxMatch *int, maxTiles *[]MatchTile) {

	n1, n2 := len(token1), len(token2)

	for i := 0; i < n1; i++ {
		if matched1[i] || n1-i < *maxMatch {
			continue
		}

		for j := 0; j < n2; j++ {
			if matched2[j] || n2-j < *maxMatch {
				continue
			}

			// 快速路径：检查是否可能产生更长的匹配
			if token1[i] != token2[j] {
				continue
			}

			// 计算匹配长度
			k := 1
			for i+k < n1 && j+k < n2 &&
				!matched1[i+k] && !matched2[j+k] &&
				token1[i+k] == token2[j+k] {
				k++
			}

			if k > *maxMatch {
				*maxMatch = k
				*maxTiles = (*maxTiles)[:0]
				*maxTiles = append(*maxTiles, MatchTile{i, j, k})
			} else if k == *maxMatch && k > minMatchLength {
				*maxTiles = append(*maxTiles, MatchTile{i, j, k})
			}
		}
	}
}

// min 返回两个整数中的较小值
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}


文件: svc\servicecontext.go
--------------------------------------------------
package svc

import (
	"fmt"
	"github.com/streadway/amqp"
	"gorm.io/gorm"
	"similarity-service/internal/config"
	repository2 "similarity-service/internal/database/repository"
	"similarity-service/internal/initializer"
)

type ServiceContext struct {
	Config      config.Config
	Initializer *initializer.InitializerManager
}

func NewServiceContext(c config.Config) *ServiceContext {
	initializer := initializer.NewInitializerManager(c)

	if err := initializer.Initialize(); err != nil {
		panic(err)
	}

	return &ServiceContext{
		Config:      c,
		Initializer: initializer,
	}
}

// 便捷方法
func (s *ServiceContext) DB() *gorm.DB {
	if s.Initializer.GetMySQLManager() != nil {
		return s.Initializer.GetMySQLManager().DB
	}
	return nil
}

func (s *ServiceContext) RabbitMQ() *amqp.Connection {
	if s.Initializer.GetRabbitMQManager() != nil {
		return s.Initializer.GetRabbitMQManager().Conn
	}
	return nil
}

func (s *ServiceContext) CommonChannel() *amqp.Channel {
	if s.Initializer.GetRabbitMQManager() != nil {
		return s.Initializer.GetRabbitMQManager().CommonChannel
	}
	return nil
}

func (s *ServiceContext) TaskSimilarityRepo() repository2.TaskSimilarityRepository {
	return s.Initializer.GetTaskSimilarityRepo()
}

func (s *ServiceContext) TaskReportsRepo() repository2.TaskReportsRepository {
	return s.Initializer.GetTaskReportsRepo()
}

func (s *ServiceContext) DataLibraryRepo() repository2.DataLibraryRepository {
	return s.Initializer.GetDataLibraryRepo()
}

func (s *ServiceContext) IsDBReady() bool {
	return s.Initializer.IsDBReady()
}

func (s *ServiceContext) SafeDB() (*gorm.DB, error) {
	if s.Initializer.GetMySQLManager() != nil {
		return s.Initializer.GetMySQLManager().SafeDB()
	}
	return nil, fmt.Errorf("数据库未初始化")
}

func (s *ServiceContext) Close() error {
	return s.Initializer.Close()
}


文件: utils\snowflake.go
--------------------------------------------------
package utils

import (
	"errors"
	"fmt"
	"net"
	"os"
	"strconv"
	"sync"
	"time"
)

const (
	// 雪花算法参数 (符合MyBatis-Plus默认配置)
	twepoch          = int64(1288834974657) // 起始时间戳 (2010-11-04 09:42:54 UTC)
	workerIDBits     = uint(5)              // 机器ID位数
	datacenterIDBits = uint(5)              // 数据中心ID位数
	sequenceBits     = uint(12)             // 序列号位数

	maxWorkerID     = int64(-1) ^ (int64(-1) << workerIDBits)
	maxDatacenterID = int64(-1) ^ (int64(-1) << datacenterIDBits)
	maxSequence     = int64(-1) ^ (int64(-1) << sequenceBits)

	workerIDShift      = sequenceBits
	datacenterIDShift  = sequenceBits + workerIDBits
	timestampLeftShift = sequenceBits + workerIDBits + datacenterIDBits
)

type Snowflake struct {
	mu            sync.Mutex
	lastTimestamp int64
	workerID      int64
	datacenterID  int64
	sequence      int64
}

var (
	instance *Snowflake
	once     sync.Once
)

// NewSnowflake 创建雪花算法实例
func NewSnowflake() *Snowflake {
	workerID := getWorkerID()
	datacenterID := getDatacenterID()

	return &Snowflake{
		workerID:     workerID,
		datacenterID: datacenterID,
	}
}

// getWorkerID 获取工作节点ID
func getWorkerID() int64 {
	// 1. 从环境变量获取
	if envID := os.Getenv("SNOWFLAKE_WORKER_ID"); envID != "" {
		if id, err := strconv.ParseInt(envID, 10, 64); err == nil && id <= maxWorkerID {
			return id
		}
	}

	// 2. 基于IP地址生成
	if interfaces, err := net.Interfaces(); err == nil {
		for _, iface := range interfaces {
			if iface.Flags&net.FlagUp != 0 && iface.Flags&net.FlagLoopback == 0 {
				if addrs, err := iface.Addrs(); err == nil {
					for _, addr := range addrs {
						if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
							if ipnet.IP.To4() != nil {
								ip := ipnet.IP.To4()
								return int64(ip[3]) & maxWorkerID
							}
						}
					}
				}
			}
		}
	}

	// 3. 默认值
	return 1
}

// getDatacenterID 获取数据中心ID
func getDatacenterID() int64 {
	// 1. 从环境变量获取
	if envID := os.Getenv("SNOWFLAKE_DATACENTER_ID"); envID != "" {
		if id, err := strconv.ParseInt(envID, 10, 64); err == nil && id <= maxDatacenterID {
			return id
		}
	}

	// 2. 基于主机名生成
	hostname, err := os.Hostname()
	if err == nil && hostname != "" {
		var hash int64
		for i := 0; i < len(hostname); i++ {
			hash = (hash << 5) - hash + int64(hostname[i])
		}
		return (hash & maxDatacenterID)
	}

	// 3. 默认值
	return 1
}

// tilNextMillis 等待下一毫秒
func (s *Snowflake) tilNextMillis(lastTimestamp int64) int64 {
	timestamp := timeGen()
	for timestamp <= lastTimestamp {
		timestamp = timeGen()
	}
	return timestamp
}

// timeGen 生成当前时间戳（毫秒）
func timeGen() int64 {
	return time.Now().UnixNano() / 1e6
}

// GenerateID 生成64位ID（返回int64）
func (s *Snowflake) GenerateID() (int64, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	timestamp := timeGen()

	if timestamp < s.lastTimestamp {
		return 0, errors.New("clock moved backwards")
	}

	if s.lastTimestamp == timestamp {
		s.sequence = (s.sequence + 1) & maxSequence
		if s.sequence == 0 {
			timestamp = s.tilNextMillis(s.lastTimestamp)
		}
	} else {
		s.sequence = 0
	}

	s.lastTimestamp = timestamp

	return ((timestamp - twepoch) << timestampLeftShift) |
		(s.datacenterID << datacenterIDShift) |
		(s.workerID << workerIDShift) |
		s.sequence, nil
}

// GenerateIDString 生成字符串格式的ID（类似MyBatis-Plus格式）
func (s *Snowflake) GenerateIDString() string {
	id, err := s.GenerateID()
	if err != nil {
		// 降级方案：使用纳秒时间戳
		return fmt.Sprintf("%d", time.Now().UnixNano())
	}
	return fmt.Sprintf("%d", id)
}

// GetInstance 获取单例实例
func GetInstance() *Snowflake {
	once.Do(func() {
		instance = NewSnowflake()
	})
	return instance
}

// GenerateID 包级函数，生成字符串ID
func GenerateID() string {
	return GetInstance().GenerateIDString()
}

