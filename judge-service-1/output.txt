├── etc
│   └── judge.yaml
└── internal
    ├── config
    │   └── config.go
    ├── dto
    │   ├── converter.go
    │   └── data.go
    ├── grutil
    │   ├── cgroup.go
    │   ├── command.go
    │   └── formate.go
    ├── judge
    │   ├── compiler.go
    │   ├── evaluater.go
    │   ├── executor.go
    │   ├── sandbox.go
    │   └── workspace.go
    ├── logic
    │   ├── common.go
    │   └── consume.go
    ├── model
    │   ├── data_judge_case.go
    │   └── data_test_case.go
    ├── nacos
    │   ├── nacos.go
    │   └── registry.go
    ├── repository
    │   └── testcase_repository.go
    └── svc
        └── servicecontext.go

11 directories, 20 files

etc/judge.yaml:
Name: judge-service
Host: 0.0.0.0
Port: 8888


# 工作空间
# Workspace: "/tmp/judge_workspace"

# Nacos 配置
Nacos:
  ServerAddr: "120.26.180.149:8848"
  Username: "nacos"  # 可选，如果为空则不使用认证
  Password: "123456"  # 可选
  # Namespace: "8fee08f3-44ea-4e26-a9b5-530c582330a3"
  Namespace: "11a37e04-ac1b-4666-9e4c-5e4f88fa78f0"
  Group: "DEFAULT_GROUP"
  DataId: "judge-service.yaml"

# MySQL 配置
MySQL:
  Host: 47.99.236.69:3306
  Username: root
  Password: "123456"
  Database: astro_code
  Charset: utf8mb4
  ParseTime: true
  Loc: Local
  MaxIdleConns: 10
  MaxOpenConns: 100
  ConnMaxLifetime: "1h"
internal/config/config.go:
package config

import (
	"github.com/zeromicro/go-zero/rest"
)

type LanguageConfig struct {
	Name        string   `json:"name"`        // 语言名称，如 "go", "python"
	SourceFile  string   `json:"sourceFile"`  // 源文件名，如 "main", "Main"
	CompileFile string   `json:"compileFile"` // 编译文件名，如 "main", "Main"
	Extension   string   `json:"extension"`   // 文件扩展名，如 ".go", ".py"
	CompileCmd  []string `json:"compileCmd"`  // 编译命令模板，如 ["go", "build", "-o", "{output}", "{source}"]
	RunCmd      []string `json:"runCmd"`      // 运行命令模板，如 ["./{output}"] 或 ["python3", "{source}"]
}

type NacosConfig struct {
	ServerAddr string `json:",optional"` // 120.26.180.149:8848
	Username   string `json:",optional"` // 可选
	Password   string `json:",optional"` // 可选
	Namespace  string `json:",optional"` // 8fee08f3-44ea-4e26-a9b5-530c582330a3
	Group      string `json:",default=DEFAULT_GROUP"`
	DataId     string `json:",optional"`
}

// MySQL 配置
type MySQLConfig struct {
	Host            string `json:",default=127.0.0.1:3306"`
	Username        string `json:",default=root"`
	Password        string `json:",optional"`
	Database        string `json:",default="`
	Charset         string `json:",default=utf8mb4"`
	ParseTime       bool   `json:",default=true"`
	Loc             string `json:",default=Local"`
	MaxIdleConns    int    `json:",default=10"`
	MaxOpenConns    int    `json:",default=100"`
	ConnMaxLifetime string `json:",default=1h"`
}

// 配置队列
type Config struct {
	rest.RestConf
	Workspace string `json:",optional"` // 工作空间
	Nacos     NacosConfig
	MySQL     MySQLConfig      `json:",optional"` // MySQL 配置
	Languages []LanguageConfig `json:",optional"` // 支持的语言配置，设为可选
	RabbitMQ  struct {
		Host        string `json:",optional"` // 主机地址
		VirtualHost string `json:",optional"` // 虚拟主机
		// 常规队列
		Common struct {
			JudgeExchange    string `json:",optional"`
			JudgeQueue       string `json:",optional"`
			JudgeRoutingKey  string `json:",optional"`
			ResultExchange   string `json:",optional"`
			ResultQueue      string `json:",optional"`
			ResultRoutingKey string `json:",optional"`
		} `json:",optional"`
	} `json:",optional"`
}

internal/dto/converter.go:
package dto

// ConvertSubmitToResult 将 JudgeSubmitDto 转换为 JudgeResultDto
func ConvertSubmitToResult(submit JudgeSubmitDto) JudgeResultDto {
	result := JudgeResultDto{
		UserId:      submit.UserId,
		ProblemId:   submit.ProblemId,
		Language:    submit.Language,
		SetId:       submit.SetId,
		Code:        submit.Code,
		SubmitType:  submit.SubmitType,
		JudgeTaskId: submit.JudgeTaskId,
		MaxTime:     0.0,
		MaxMemory:   0.0,
		ID:          submit.ID,
		IsSet:       submit.IsSet,
		Status:      StatusPending, // 初始状态为空，等待判题结果
		Message:     "",            // 初始消息为空
	}

	// 转换测试用例
	result.TestCase = make([]SubmitTestCase, len(submit.TestCase))
	for i, testCase := range submit.TestCase {
		result.TestCase[i] = SubmitTestCase{
			Input:     testCase.Input,
			Output:    "",              // 初始输出为空
			Except:    testCase.Output, // 预期输出来自提交的测试用例
			MaxTime:   0.0,
			MaxMemory: 0.0,
			Message:   "",            // 初始消息为空
			Status:    StatusPending, // 初始状态为空
		}
	}

	return result
}

// UpdateResultWithTestCase 更新结果中的测试用例信息
func UpdateResultWithTestCase(result *JudgeResultDto, index int, output string, status JudgeStatus, message string) {
	if index >= 0 && index < len(result.TestCase) {
		result.TestCase[index].Output = output
		result.TestCase[index].Status = status
		result.TestCase[index].Message = message
	}
}

// DetermineFinalStatus 根据所有测试用例的状态确定最终状态
func DetermineFinalStatus(result *JudgeResultDto) {
	if len(result.TestCase) == 0 {
		result.Status = StatusSystemError
		result.Message = "No test cases provided"
		return
	}

	// 检查是否有编译错误或系统错误
	for _, testCase := range result.TestCase {
		if testCase.Status == StatusCompilationError || testCase.Status == StatusSystemError {
			result.Status = testCase.Status
			result.Message = testCase.Message
			return
		}
	}

	// 检查其他错误状态
	for _, testCase := range result.TestCase {
		if testCase.Status != StatusAccepted {
			result.Status = testCase.Status
			result.Message = testCase.Message
			return
		}
	}

	// 所有测试用例都通过
	result.Status = StatusAccepted
	result.Message = "All test cases passed"
}

// ConvertToFailedResult 创建一个失败的结果对象
func ConvertToFailedResult(submit JudgeSubmitDto, status JudgeStatus, message string) JudgeResultDto {
	result := ConvertSubmitToResult(submit)
	result.Status = status
	result.Message = message

	// 更新所有测试用例状态
	for i := range result.TestCase {
		result.TestCase[i].Status = status
		result.TestCase[i].Message = message
	}

	return result
}

internal/dto/data.go:
package dto

type JudgeStatus string

const (
	// Basic states
	StatusPending    JudgeStatus = "PENDING"
	StatusJudging    JudgeStatus = "JUDGING"
	StatusCompiling  JudgeStatus = "COMPILING"
	StatusCompiledOK JudgeStatus = "COMPILED_OK"
	StatusRunning    JudgeStatus = "RUNNING"

	// Result states
	StatusAccepted            JudgeStatus = "ACCEPTED"
	StatusWrongAnswer         JudgeStatus = "WRONG_ANSWER"
	StatusTimeLimitExceeded   JudgeStatus = "TIME_LIMIT_EXCEEDED"
	StatusMemoryLimitExceeded JudgeStatus = "MEMORY_LIMIT_EXCEEDED"
	StatusRuntimeError        JudgeStatus = "RUNTIME_ERROR"
	StatusCompilationError    JudgeStatus = "COMPILATION_ERROR"
	StatusPresentationError   JudgeStatus = "PRESENTATION_ERROR"
	StatusOutputLimitExceeded JudgeStatus = "OUTPUT_LIMIT_EXCEEDED"

	// Special states
	StatusPartialAccepted    JudgeStatus = "PARTIAL_ACCEPTED"
	StatusSystemError        JudgeStatus = "SYSTEM_ERROR"
	StatusRestrictedFunction JudgeStatus = "RESTRICTED_FUNCTION"
	StatusDangerousOperation JudgeStatus = "DANGEROUS_OPERATION"
	StatusQueuing            JudgeStatus = "QUEUING"
	StatusHidden             JudgeStatus = "HIDDEN"
	StatusSkipped            JudgeStatus = "SKIPPED"
	StatusFrozen             JudgeStatus = "FROZEN"

	// Contest-specific states
	StatusFirstBlood     JudgeStatus = "FIRST_BLOOD"
	StatusHacked         JudgeStatus = "HACKED"
	StatusPendingRejudge JudgeStatus = "PENDING_REJUDGE"
	StatusRejudging      JudgeStatus = "REJUDGING"

	// Other states
	StatusUnknownError          JudgeStatus = "UNKNOWN_ERROR"
	StatusValidatorError        JudgeStatus = "VALIDATOR_ERROR"
	StatusCheckerError          JudgeStatus = "CHECKER_ERROR"
	StatusIdlenessLimitExceeded JudgeStatus = "IDLENESS_LIMIT_EXCEEDED"
	StatusSecurityViolation     JudgeStatus = "SECURITY_VIOLATION"
	StatusIgnored               JudgeStatus = "IGNORED"
)

/* 提交题目 */
type JudgeSubmitDto struct {
	UserId      string     `json:"userId"`
	ProblemId   string     `json:"problemId"`
	SetId       string     `json:"setId"`
	Language    string     `json:"language"`
	Code        string     `json:"code"`
	SubmitType  bool       `json:"submitType"`
	MaxTime     float64    `json:"maxTime"`   // ms
	MaxMemory   float64    `json:"maxMemory"` // kb
	TestCase    []TestCase `json:"testCase"`
	ID          string     `json:"id"`
	IsSet       bool       `json:"isSet"`
	JudgeTaskId string     `json:"judgeTaskId"`
}

type JudgeResultDto struct {
	UserId      string           `json:"userId"`
	ProblemId   string           `json:"problemId"`
	Language    string           `json:"language"`
	SetId       string           `json:"setId"`
	Code        string           `json:"code"`
	SubmitType  bool             `json:"submitType"`
	MaxTime     float64          `json:"maxTime"`   // ms
	MaxMemory   float64          `json:"maxMemory"` // kb
	TestCase    []SubmitTestCase `json:"testCase"`
	Message     string           `json:"message"`
	ID          string           `json:"id"`
	IsSet       bool             `json:"isSet"`
	Status      JudgeStatus      `json:"status"`
	ExitCode    int              `json:"exitCode"` // 程序退出码
	JudgeTaskId string           `json:"judgeTaskId"`
}

/* 测试用例 */
type TestCase struct {
	Input  string `json:"input"`
	Output string `json:"output"`
}

/* 返回测试用例 */
type SubmitTestCase struct {
	Input     string      `json:"input"`
	Output    string      `json:"output"`
	Except    string      `json:"except"`
	MaxTime   float64     `json:"maxTime"`   // ms
	MaxMemory float64     `json:"maxMemory"` // kb
	Message   string      `json:"message"`
	Status    JudgeStatus `json:"status"`
	ExitCode  int         `json:"exitCode"` // 程序退出码
}

internal/grutil/cgroup.go:
package grutil

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
)

// createCgroup 创建cgroup
func CreateCgroup(maxMemory float64) (string, error) {
	cgroupName := GenerateCgroupName()
	cgroupPath := filepath.Join("/sys/fs/cgroup", cgroupName)

	// 创建cgroup目录
	if err := os.MkdirAll(cgroupPath, 0755); err != nil {
		return "", fmt.Errorf("创建cgroup目录失败: %v", err)
	}

	// 设置内存限制（单位：字节）
	memoryLimit := maxMemory * 1024 // KB 转字节
	memoryMaxPath := filepath.Join(cgroupPath, "memory.max")
	if err := os.WriteFile(memoryMaxPath, []byte(strconv.FormatFloat(memoryLimit, 'f', -1, 64)), 0644); err != nil {
		return "", fmt.Errorf("设置内存限制失败: %v", err)
	}

	// 禁用swap
	memorySwapMaxPath := filepath.Join(cgroupPath, "memory.swap.max")
	if err := os.WriteFile(memorySwapMaxPath, []byte("0"), 0644); err != nil {
		logx.Errorf("禁用swap失败: %v", err)
	}

	// 验证内存限制是否设置成功
	setLimit, err := os.ReadFile(memoryMaxPath)
	if err != nil {
		return "", fmt.Errorf("验证内存限制失败: %v", err)
	}
	logx.Infof("设置的内存限制: %s bytes", strings.TrimSpace(string(setLimit)))
	return cgroupPath, nil
}

// createCgroup 创建cgroup
func CreateCgroupNoMemory() (string, error) {
	cgroupName := GenerateCgroupName()
	cgroupPath := filepath.Join("/sys/fs/cgroup", cgroupName)

	// 创建cgroup目录
	if err := os.MkdirAll(cgroupPath, 0755); err != nil {
		return "", fmt.Errorf("创建cgroup目录失败: %v", err)
	}

	// 禁用swap
	memorySwapMaxPath := filepath.Join(cgroupPath, "memory.swap.max")
	if err := os.WriteFile(memorySwapMaxPath, []byte("0"), 0644); err != nil {
		logx.Errorf("禁用swap失败: %v", err)
	}

	return cgroupPath, nil
}

// getMemoryUsage 从cgroup读取峰值内存使用
func GetMemoryUsage(cgroupPath string) (uint64, error) {
	// 首先检查cgroup目录是否存在
	if _, err := os.Stat(cgroupPath); os.IsNotExist(err) {
		logx.Errorf("cgroup目录不存在: %s", cgroupPath)
		return 0, fmt.Errorf("cgroup目录不存在")
	}

	// 读取 memory.peak 文件
	peakPath := filepath.Join(cgroupPath, "memory.peak")
	content, err := os.ReadFile(peakPath)
	if err != nil {
		logx.Errorf("读取memory.peak失败: %s, 错误: %v", peakPath, err)
		return 0, fmt.Errorf("读取memory.peak失败: %v", err)
	}

	peakContent := strings.TrimSpace(string(content))
	logx.Infof("memory.peak 内容: '%s'", peakContent)

	// 读取 memory.current 文件
	currentPath := filepath.Join(cgroupPath, "memory.current")
	currentContent, err := os.ReadFile(currentPath)
	if err != nil {
		logx.Errorf("读取memory.current失败: %v", err)
	} else {
		logx.Infof("memory.current 内容: '%s'", strings.TrimSpace(string(currentContent)))
	}

	// 解析内存使用量
	memoryUsed, err := strconv.ParseUint(peakContent, 10, 64)
	if err != nil {
		logx.Errorf("解析内存使用量失败: '%s', 错误: %v", peakContent, err)
		return 0, fmt.Errorf("解析内存使用量失败: %v", err)
	}

	logx.Infof("解析后的内存使用量: %d bytes", memoryUsed)
	return memoryUsed, nil
}

func GenerateCgroupName() string {
	pid := os.Getpid()
	timestamp := time.Now().Format("150405") // 时分秒

	// 生成3字节随机数
	randomBytes := make([]byte, 3)
	rand.Read(randomBytes)
	randomStr := base64.RawURLEncoding.EncodeToString(randomBytes)

	return fmt.Sprintf("judge-p%d-%s-%s", pid, timestamp, randomStr)
}

// setCgroupForProcess 将进程添加到cgroup
func SetCgroupForProcess(cgroupPath string, pid int) error {
	procsFile := filepath.Join(cgroupPath, "cgroup.procs")
	// 检查进程是否存在
	if _, err := os.FindProcess(pid); err != nil {
		return fmt.Errorf("进程不存在: %d", pid)
	}

	// 将进程PID写入cgroup.procs文件
	return os.WriteFile(procsFile, []byte(strconv.Itoa(pid)), 0644)
}

// cleanupCgroup 清理cgroup
func CleanupCgroup(cgroupPath string) {
	if err := os.RemoveAll(cgroupPath); err != nil {
		logx.Errorf("清理cgroup失败: %v", err)
	} else {
		logx.Infof("清理cgroup: %s", cgroupPath)
	}
}

// checkOOMEvent 检查cgroup是否发生了OOM事件
func CheckOOMEvent(cgroupPath string) bool {
	eventsPath := filepath.Join(cgroupPath, "memory.events")
	content, err := os.ReadFile(eventsPath)
	if err != nil {
		logx.Errorf("读取memory.events失败: %v", err)
		return false
	}

	// 解析事件文件
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "oom ") {
			parts := strings.Split(line, " ")
			if len(parts) >= 2 {
				count, err := strconv.Atoi(strings.TrimSpace(parts[1]))
				if err == nil && count > 0 {
					logx.Infof("检测到OOM事件: %s", line)
					return true
				}
			}
		}
	}

	return false
}

internal/grutil/command.go:
package grutil

import (
	"judge-service/internal/config"
	"strings"

	"github.com/zeromicro/go-zero/core/logx"
)

// getRunCommand 获取执行命令
func GetRunCommand(config config.LanguageConfig, sourceFile string, buildFile string) []string {
	runCmd := make([]string, len(config.RunCmd))
	for i, part := range config.RunCmd {
		// runCmd[i] = strings.ReplaceAll(part, "{exec}", buildFile)
		runCmd[i] = strings.ReplaceAll(part, "{source}", sourceFile)
		runCmd[i] = strings.ReplaceAll(runCmd[i], "{exec}", buildFile)
	}

	logx.Infof("得到运行命令: %s", runCmd)
	return runCmd
}

func GetCompileCommand(config config.LanguageConfig, sourceFile string, buildFile string) []string {
	compileCmd := make([]string, len(config.CompileCmd))
	for i, part := range config.CompileCmd {
		compileCmd[i] = strings.ReplaceAll(part, "{source}", sourceFile)
		compileCmd[i] = strings.ReplaceAll(compileCmd[i], "{exec}", buildFile)
	}

	logx.Infof("得到编译命令: %s", compileCmd)
	return compileCmd
}

internal/grutil/formate.go:
package grutil

import (
	"regexp"
	"strings"
)

func FormatBytesKB(bytes uint64) float64 {
	return float64(bytes) / 1024
}

// normalizeLineEndings 将不同风格的换行符统一为\n
func NormalizeLineEndings(str string) string {
	// 将\r\n替换为\n
	str = strings.ReplaceAll(str, "\r\n", "\n")
	// 将单独的\r也替换为\n（处理Mac OS旧格式）
	str = strings.ReplaceAll(str, "\r", "\n")
	return str
}

// SplitAndNormalize 将文本按行分割并标准化每行
func SplitAndNormalize(str string) []string {
	// 标准化换行符
	str = strings.ReplaceAll(str, "\r\n", "\n")
	str = strings.ReplaceAll(str, "\r", "\n")

	lines := strings.Split(str, "\n")
	normalized := make([]string, 0, len(lines))

	for _, line := range lines {
		// 移除每行的首尾空白
		line = strings.TrimSpace(line)
		if line != "" { // 可选：是否忽略空行
			normalized = append(normalized, line)
		}
	}

	return normalized
}

// 评估两个标准答案与用户提交是否相同
func CompareOutput(ans string, output string) bool {
	// if NormalizeLineEndings(ans) == NormalizeLineEndings(output) {
	// 	return true
	// } else {
	// 	return false
	// }
	// CompareOutput 按行比较，忽略行尾差异
	ansLines := SplitAndNormalize(ans)
	outputLines := SplitAndNormalize(output)

	if len(ansLines) != len(outputLines) {
		return false
	}

	for i := range ansLines {
		if ansLines[i] != outputLines[i] {
			return false
		}
	}

	return true
}

// filterFilePath 过滤掉消息中的文件路径
func FilterFilePath(message string) string {
	// 使用正则表达式匹配并移除文件路径
	// 匹配两种格式：
	// 1. /path/file.cpp:123:456:
	// 2. /path/file.cpp: description
	// pattern := `/\S+?\.(cpp|c|java|py|js|go)(?::\d+:\d+:|:\s*)`
	// re := regexp.MustCompile(pattern)

	// // 移除文件路径部分，只保留错误信息
	// filtered := re.ReplaceAllString(message, "")

	// // 如果过滤后为空，返回原始消息
	// if filtered == "" {
	// 	return message
	// }

	// return filtered


	 // 匹配常见的文件路径模式
	patterns := []string{
        `/[^/]+?/([^/]+?\.(cpp|c|java|py|js|go)):\d+:\d+:`,  // Unix路径，保留文件名
        `/[^/]+?/([^/]+?\.(cpp|c|java|py|js|go)):\s*`,       // Unix路径，保留文件名  
        `[a-zA-Z]:\\[^\\]+?\\([^\\]+?\.(cpp|c|java|py|js|go)):`, // Windows路径，保留文件名
    }
    
    for _, pattern := range patterns {
        re := regexp.MustCompile(pattern)
        message = re.ReplaceAllString(message, "")
    }
    
    return message
}

internal/judge/compiler.go:
package judge

import (
	"bytes"
	"context"
	"fmt"
	"judge-service/internal/dto"
	"judge-service/internal/grutil"
	"os/exec"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
)

type Compiler struct {
	ctx     context.Context
	Sandbox Sandbox
	mu      sync.Mutex // 添加互斥锁防止竞争条件
}

// 创建编译器，传入上下文，沙箱
func NewCompiler(ctx context.Context, sandbox Sandbox) *Compiler {
	return &Compiler{
		ctx:     ctx,
		Sandbox: sandbox,
	}
}

// 实际执行编译
func (e *Compiler) Execute() (*dto.JudgeResultDto, error) {
	result := dto.ConvertSubmitToResult(e.Sandbox.Workspace.judgeSubmit)
	comCmd := grutil.GetCompileCommand(e.Sandbox.Workspace.langConfig, e.Sandbox.Workspace.SourceFile, e.Sandbox.Workspace.BuildFile)

	cgroupPath, err := grutil.CreateCgroupNoMemory()
	if err != nil {
		logx.Errorf("创建cgroup失败: %v", err)
		result.Status = dto.StatusSystemError
		result.Message = fmt.Sprintf("创建cgroup失败: %v", err)
		return &result, err
	}

	// 编译超时保护，默认编译时间限制 + 5 秒
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, comCmd[0], comCmd[1:]...)
	cmd.Dir = e.Sandbox.Workspace.BuildPath

	cmd.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true,
		Cloneflags: syscall.CLONE_NEWNS |
			syscall.CLONE_NEWUTS |
			syscall.CLONE_NEWPID |
			syscall.CLONE_NEWNET |
			syscall.CLONE_NEWIPC,
		Unshareflags: syscall.CLONE_NEWNS,
	}

	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.Stdout = &stdoutBuf
	cmd.Stderr = &stderrBuf

	err = cmd.Start()
	if err != nil {
		result.Status = dto.StatusRuntimeError
		result.Message = fmt.Sprintf("启动进程失败: %v", err)
		logx.Errorf("启动进程失败: %v", result.Message)
		return &result, err
	}
	e.mu.Lock()

	// 立即暂停进程
	syscall.Kill(cmd.Process.Pid, syscall.SIGSTOP)

	pgid := cmd.Process.Pid
	if err := grutil.SetCgroupForProcess(cgroupPath, pgid); err != nil {
		syscall.Kill(-pgid, syscall.SIGKILL)
		result.Status = dto.StatusRuntimeError
		result.Message = fmt.Sprintf("设置cgroup失败: %v", err)
		logx.Errorf("设置cgroup失败: %v", result.Message)
		grutil.CleanupCgroup(cgroupPath)
		return &result, err
	}

	// 进程即将恢复执行
	startTime := time.Now()
	syscall.Kill(cmd.Process.Pid, syscall.SIGCONT)
	e.mu.Unlock()

	done := make(chan error, 1)
	go func() {
		done <- cmd.Wait()
	}()

	select {
	case <-ctx.Done():
		syscall.Kill(-pgid, syscall.SIGKILL)
		elapsed := time.Since(startTime)
		memoryUsed, _ := grutil.GetMemoryUsage(cgroupPath)
		result.MaxMemory = grutil.FormatBytesKB(memoryUsed)
		result.MaxTime = float64(elapsed.Milliseconds())
		result.Status = dto.StatusCompilationError
		stderr := stderrBuf.String()
		if strings.TrimSpace(stderr) != "" {
			result.Message = stderr
			result.Status = dto.StatusCompilationError
		}
		// result.ExitCode = -1 // 或者使用其他特殊值表示超时

		logx.Errorf("超时杀死整个进程组，运行时间: %v ms 时间限制 %v ms", elapsed, e.Sandbox.Workspace.judgeSubmit.MaxTime)
		return &result, err
	case err := <-done:
		elapsed := time.Since(startTime)
		memoryUsed, _ := grutil.GetMemoryUsage(cgroupPath)
		result.MaxMemory = grutil.FormatBytesKB(memoryUsed)
		result.MaxTime = float64(elapsed.Milliseconds())

		// // 获取退出码
		// exitCode := 0
		// if err != nil {
		// 	if exitError, ok := err.(*exec.ExitError); ok {
		// 		// 获取进程退出状态
		// 		if status, ok := exitError.Sys().(syscall.WaitStatus); ok {
		// 			exitCode = status.ExitStatus()
		// 		} else {
		// 			// 如果无法获取详细的退出状态，使用通用错误码
		// 			exitCode = -1
		// 		}
		// 	} else {
		// 		// 非退出错误，设置特殊错误码
		// 		exitCode = -2
		// 	}
		// }
		// result.ExitCode = exitCode

		stderr := stderrBuf.String()
		if strings.TrimSpace(stderr) != "" {
			result.Status = dto.StatusCompilationError
			result.Message = stderr
			grutil.CleanupCgroup(cgroupPath)
			// // 根据退出码设置状态（如果需要）
			// if exitCode != 0 {
			// 	result.Status = dto.StatusRuntimeError
			// 	result.Message = fmt.Sprintf("程序异常退出，退出码: %d", exitCode)
			// }
			return &result, err
		}

		logx.Infof("编译完成, 内存使用: %d bytes (峰值), 程序退出状态: %v", memoryUsed, err)
		result.Status = dto.StatusCompiledOK
		grutil.CleanupCgroup(cgroupPath)
		// 根据退出码设置状态（如果需要）
		// if exitCode != 0 {
		// 	result.Status = dto.StatusRuntimeError
		// 	result.Message = fmt.Sprintf("程序异常退出，退出码: %d", exitCode)
		// }
		return &result, err
	}
}

internal/judge/evaluater.go:
package judge

import (
	"context"
	"judge-service/internal/dto"
	"judge-service/internal/grutil"

	"github.com/zeromicro/go-zero/core/logx"
)

type Evaluater struct {
	ctx     context.Context
	Sandbox Sandbox
	result  *dto.JudgeResultDto
}

// 创建执行器，传入上下文，沙箱
func NewEvaluater(ctx context.Context, sandbox Sandbox, resultData *dto.JudgeResultDto) *Evaluater {
	return &Evaluater{
		ctx:     ctx,
		Sandbox: sandbox,
		result:  resultData,
	}
}

// 实际执行
func (e *Evaluater) Execute() (*dto.JudgeResultDto, error) {
	maxTime := 0.0
	maxMemory := 0.0
	statusCount := make(map[dto.JudgeStatus]int)
	messageCount := make(map[string]int)

	for i := range e.result.TestCase {
		testCase := &e.result.TestCase[i] // 获取指向原始元素的指针

		// 计算最大值
		if testCase.MaxTime > maxTime {
			maxTime = testCase.MaxTime
		}
		if testCase.MaxMemory > maxMemory {
			maxMemory = testCase.MaxMemory
		}

		if testCase.Status == dto.StatusPending {
			if grutil.CompareOutput(testCase.Except, testCase.Output) {
				testCase.Status = dto.StatusAccepted
			} else {
				testCase.Status = dto.StatusWrongAnswer
			}
		}

		// 统计各种状态的数量
		statusCount[testCase.Status]++
		// 消息聚合
		messageCount[testCase.Message]++
	}

	// 设置最终的最大值
	e.result.MaxTime = maxTime
	e.result.MaxMemory = maxMemory

	// 根据状态统计结果设置最终状态
	e.result.Status = e.aggregateStatus(statusCount)
	e.result.Message = e.aggregateMessage(messageCount)

	logx.Infof("评估完成")
	return e.result, nil
}

// 聚合状态，优先异常状态，然后选择数量最多的状态
func (e *Evaluater) aggregateStatus(statusCount map[dto.JudgeStatus]int) dto.JudgeStatus {
	if len(statusCount) == 0 {
		return dto.StatusPending
	}

	// 定义异常状态优先级（从高到低）
	exceptionStatuses := []dto.JudgeStatus{
		dto.StatusCompilationError,
		dto.StatusRuntimeError,
		dto.StatusTimeLimitExceeded,
		dto.StatusMemoryLimitExceeded,
		dto.StatusOutputLimitExceeded,
		dto.StatusSystemError,
	}

	// 首先检查是否有异常状态
	for _, status := range exceptionStatuses {
		if count, exists := statusCount[status]; exists && count > 0 {
			return status
		}
	}

	// 如果没有异常状态，则按照AC、PC、WA的优先级处理
	acCount := statusCount[dto.StatusAccepted]
	pcCount := statusCount[dto.StatusPartialAccepted]
	waCount := statusCount[dto.StatusWrongAnswer]
	otherCount := 0

	// 计算其他状态的总数
	for status, count := range statusCount {
		if status != dto.StatusAccepted &&
			status != dto.StatusPartialAccepted &&
			status != dto.StatusWrongAnswer &&
			status != dto.StatusSkipped &&
			status != dto.StatusPending {
			otherCount += count
		}
	}

	// 判断逻辑
	if acCount == len(e.result.TestCase) {
		// 全部正确
		return dto.StatusAccepted
	} else if acCount > 0 && (acCount+pcCount+waCount+otherCount == len(e.result.TestCase)) {
		if pcCount > 0 || waCount > 0 || otherCount > 0 {
			// 有部分正确，也有错误
			return dto.StatusPartialAccepted
		}
	} else if waCount == len(e.result.TestCase) {
		// 全部错误
		return dto.StatusWrongAnswer
	} else if pcCount > 0 {
		// 有部分正确的情况
		return dto.StatusPartialAccepted
	}

	// 默认情况：选择数量最多的状态（排除跳过和待判状态）
	maxCount := 0
	mostCommonStatus := dto.StatusPending

	for status, count := range statusCount {
		if status != dto.StatusSkipped &&
			status != dto.StatusPending &&
			count > maxCount {
			maxCount = count
			mostCommonStatus = status
		}
	}

	// 如果所有测试用例都是跳过或待判状态
	if mostCommonStatus == dto.StatusPending &&
		(statusCount[dto.StatusSkipped] > 0 || statusCount[dto.StatusPending] > 0) {
		// 检查是否有实际的状态
		hasActualStatus := false
		for status := range statusCount {
			if status != dto.StatusSkipped && status != dto.StatusPending {
				hasActualStatus = true
				break
			}
		}
		if !hasActualStatus {
			return dto.StatusPending
		}
	}

	return mostCommonStatus
}

// aggregateMessage 聚合消息
func (e *Evaluater) aggregateMessage(messageCount map[string]int) string {
	if len(messageCount) == 0 {
		return ""
	}

	var maxCount int
	var mostFrequentMessage string

	for message, count := range messageCount {
		if count > maxCount {
			maxCount = count
			mostFrequentMessage = message
		}
	}

	return mostFrequentMessage
}

internal/judge/executor.go:
package judge

import (
	"bytes"
	"context"
	"fmt"
	"judge-service/internal/dto"
	"judge-service/internal/grutil"
	"os/exec"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
)

type Executor struct {
	ctx     context.Context
	Sandbox Sandbox
	mu      sync.Mutex // 添加互斥锁防止竞争条件
}

// 创建执行器，传入上下文，沙箱
func NewExecutor(ctx context.Context, sandbox Sandbox) *Executor {
	return &Executor{
		ctx:     ctx,
		Sandbox: sandbox,
	}
}

// 执行器执行
func (e *Executor) Execute() (*dto.JudgeResultDto, error) {
	result := dto.ConvertSubmitToResult(e.Sandbox.Workspace.judgeSubmit)

	runCmd := grutil.GetRunCommand(e.Sandbox.Workspace.langConfig, e.Sandbox.Workspace.SourceFile, e.Sandbox.Workspace.BuildFile)
	for i := range result.TestCase {
		testCase := &result.TestCase[i]
		// 执行超内存保护，默认编译内存限制 + 配置内存限制
		cgroupPath, err := grutil.CreateCgroup(e.Sandbox.Workspace.judgeSubmit.MaxMemory)
		if err != nil {
			logx.Errorf("创建 CGroup 失败: %v", err)
			result.Status = dto.StatusSystemError
			result.Message = fmt.Sprintf("创建 CGroup 失败: %v", err)
			return &result, err
		}
		err = e.executeTestCase(testCase, i, runCmd, cgroupPath)
		if err != nil {
			result.Status = dto.StatusSystemError
			result.Message = fmt.Sprintf("执行用例 %d 失败: %v", i, err)
			return &result, err
		}
		grutil.CleanupCgroup(cgroupPath)
	}
	return &result, nil
}

func (e *Executor) executeTestCase(testCase *dto.SubmitTestCase, index int, runCmd []string, cgroupPath string) error {
	// 执行超时保护，默认执行时间限制 + 配置时间限制
	timeout := time.Duration(e.Sandbox.Workspace.judgeSubmit.MaxTime)*time.Millisecond + 30*time.Millisecond
	// 打印timeout值
	logx.Infof("测试用例 %d 的超时时间设置为: %v", index, timeout)
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel() // 设置超时时间，根据提交的最大时间限制

	cmd := exec.CommandContext(ctx, runCmd[0], runCmd[1:]...)
	// 设置进程属性，创建新的命名空间进行隔离
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true, // 设置进程组ID，便于管理进程组
		Cloneflags: syscall.CLONE_NEWNS | // 新的挂载命名空间
			syscall.CLONE_NEWUTS | // 新的UTS命名空间（主机名和域名）
			syscall.CLONE_NEWPID | // 新的PID命名空间
			syscall.CLONE_NEWNET | // 新的网络命名空间
			syscall.CLONE_NEWIPC, // 新的IPC命名空间
		Unshareflags: syscall.CLONE_NEWNS, // 取消共享挂载命名空间
	}

	// 设置标准输入为测试用例的输入
	cmd.Stdin = strings.NewReader(testCase.Input)
	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.Stdout = &stdoutBuf
	cmd.Stderr = &stderrBuf

	// 启动命令
	err := cmd.Start()
	if err != nil {
		testCase.Status = dto.StatusRuntimeError
		testCase.Message = fmt.Sprintf("启动进程失败: %v", err)
		logx.Errorf("启动进程失败: %v", testCase.Message)
		return err
	}
	// 加锁确保对进程操作的原子性
	e.mu.Lock()

	// 立即暂停进程，以便设置cgroup
	syscall.Kill(cmd.Process.Pid, syscall.SIGSTOP)

	// 获取进程组ID
	pgid := cmd.Process.Pid

	// 将进程添加到cgroup进行资源限制
	if err := grutil.SetCgroupForProcess(cgroupPath, pgid); err != nil {
		syscall.Kill(-pgid, syscall.SIGKILL) // 将进程添加到cgroup进行资源限制
		testCase.Status = dto.StatusRuntimeError
		testCase.Message = fmt.Sprintf("设置cgroup失败: %v", err)
		logx.Errorf("设置cgroup失败: %v", testCase.Message)
		return err
	}

	startTime := time.Now() // 将进程添加到cgroup进行资源限制
	syscall.Kill(cmd.Process.Pid, syscall.SIGCONT)
	e.mu.Unlock() // 解锁，允许其他操作

	done := make(chan error, 1) // 创建通道等待命令执行完成
	go func() {
		done <- cmd.Wait()
	}()

	select {
	case <-ctx.Done():
		// 获取内存使用情况
		syscall.Kill(-pgid, syscall.SIGKILL)
		elapsed := time.Since(startTime)
		// 获取内存使用情况
		memoryUsed, _ := grutil.GetMemoryUsage(cgroupPath)
		testCase.MaxMemory = grutil.FormatBytesKB(memoryUsed)
		testCase.MaxTime = float64(elapsed.Milliseconds())
		testCase.Status = dto.StatusTimeLimitExceeded
		testCase.Output = stdoutBuf.String()
		// 检查是否有错误输出
		stderr := stderrBuf.String()
		if strings.TrimSpace(stderr) != "" {
			testCase.Message = stderr
			testCase.Status = dto.StatusRuntimeError
		}
		// // 超时情况下退出码通常不可用，设置为特定值
		// testCase.ExitCode = -1 // 或者使用其他特殊值表示超时

		logx.Errorf("超时杀死整个进程组，运行时间: %v ms 时间限制 %v ms", elapsed, e.Sandbox.Workspace.judgeSubmit.MaxTime)
	case err := <-done:
		// 命令正常完成或出错
		elapsed := time.Since(startTime)
		memoryUsed, _ := grutil.GetMemoryUsage(cgroupPath)
		testCase.MaxMemory = grutil.FormatBytesKB(memoryUsed)
		testCase.MaxTime = float64(elapsed.Milliseconds())
		// 时间判断
		if elapsed > time.Duration(e.Sandbox.Workspace.judgeSubmit.MaxTime)*time.Millisecond {
			testCase.Status = dto.StatusTimeLimitExceeded
		}

		// // 获取退出码
		// exitCode := 0
		// if err != nil {
		// 	if exitError, ok := err.(*exec.ExitError); ok {
		// 		// 获取进程退出状态
		// 		if status, ok := exitError.Sys().(syscall.WaitStatus); ok {
		// 			exitCode = status.ExitStatus()
		// 		} else {
		// 			// 如果无法获取详细的退出状态，使用通用错误码
		// 			exitCode = -1
		// 		}
		// 	} else {
		// 		// 非退出错误，设置特殊错误码
		// 		exitCode = -2
		// 	}
		// }
		// testCase.ExitCode = exitCode

		// 检查是否发生内存溢出
		if grutil.CheckOOMEvent(cgroupPath) {
			testCase.Status = dto.StatusMemoryLimitExceeded
		}
		testCase.Output = stdoutBuf.String()
		// 检查是否有错误输出
		stderr := stderrBuf.String()
		if strings.TrimSpace(stderr) != "" {
			testCase.Message = stderr
			testCase.Status = dto.StatusRuntimeError
		}

		// // 根据退出码设置状态（如果需要）
		// if exitCode != 0 {
		// 	testCase.Status = dto.StatusRuntimeError
		// 	testCase.Message = fmt.Sprintf("程序异常退出，退出码: %d", exitCode)
		// }

		logx.Infof("测试用例 %d 完成, 运行时间: %v ms 时间限制 %v ms, 内存使用: %d KB, 程序退出状态: %v", index, elapsed, e.Sandbox.Workspace.judgeSubmit.MaxTime, grutil.FormatBytesKB(memoryUsed), err)
	}

	return nil
}

internal/judge/sandbox.go:
package judge

import (
	"context"
	"judge-service/internal/dto"

	"github.com/zeromicro/go-zero/core/logx"
)

type Sandbox struct {
	ctx       context.Context
	Workspace Workspace
}

// 创建沙盒，传入上下文，工作空间
func NewSandbox(ctx context.Context, workspace Workspace) *Sandbox {
	return &Sandbox{
		ctx:       ctx,
		Workspace: workspace,
	}
}

// 编译，返回编译结果
func (s *Sandbox) Compile() (*dto.JudgeResultDto, error) {
	logx.Info("开始编译")
	c := NewCompiler(s.ctx, *s)
	return c.Execute()
}

// 执行，返回执行结果
func (s *Sandbox) Run() (*dto.JudgeResultDto, error) {
	logx.Info("开始执行")
	r := NewExecutor(s.ctx, *s)
	return r.Execute()
}

// 评估
func (s *Sandbox) Evaluater(resultData *dto.JudgeResultDto) (*dto.JudgeResultDto, error) {
	logx.Info("开始评估")
	r := NewEvaluater(s.ctx, *s, resultData)
	return r.Execute()
}

internal/judge/workspace.go:
package judge

import (
	"context"
	"fmt"
	"judge-service/internal/config"
	"judge-service/internal/dto"
	"judge-service/internal/grutil"
	"judge-service/internal/svc"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/zeromicro/go-zero/core/logx"
)

type Workspace struct {
	ctx         context.Context
	config      config.Config
	startTime   time.Time
	langConfig  config.LanguageConfig
	judgeSubmit dto.JudgeSubmitDto
	RootPath    string // 工作空间根目录
	SourcePath  string // 源代码目录
	SourceFile  string // 源代码文件
	BuildPath   string // 编译目录
	BuildFile   string // 编译文件
	RunsPath    string // 运行目录
	svcCtx      *svc.ServiceContext
}

// NewWorkspace 创建工作空间,上下文/配置/提交信息,返回 工作空间实例 和 提交信息
func NewWorkspace(ctx context.Context, config config.Config, judgeSubmitDto dto.JudgeSubmitDto, svcCtx *svc.ServiceContext) (*Workspace, *dto.JudgeResultDto) {
	// 生成工作空间ID
	workUuid := uuid.New()
	submissionID := strings.ReplaceAll(workUuid.String(), "-", "") // 替换-为空，生成没有连字符的UUID

	workDir := config.Workspace                  // 工作空间根目录
	root := filepath.Join(workDir, submissionID) // 本次工作空间根目录

	ws := &Workspace{
		ctx:         ctx,                           // 使用传入的ctx
		startTime:   time.Now(),                    // 记录开始时间，用来计算任务总耗时
		config:      config,                        // 系统配置
		judgeSubmit: judgeSubmitDto,                // 提交信息
		RootPath:    root,                          // 根目录
		SourcePath:  filepath.Join(root, "source"), // 源代码目录
		BuildPath:   filepath.Join(root, "build"),  // 编译目录
		RunsPath:    filepath.Join(root, "runs"),   // 运行目录
		svcCtx:      svcCtx,
	}

	// 创建目录
	if err := ws.createDirs(); err != nil {
		// err 不为空，说明创建目录失败，返回错误信息
		result := dto.ConvertSubmitToResult(judgeSubmitDto)
		result.Status = dto.StatusSystemError
		result.Message = fmt.Sprintf("创建工作空间失败: %v", err)
		return nil, &result
	}

	return ws, nil
}

// 独立的创建目录方法
func (w *Workspace) createDirs() error {
	dirs := []string{w.SourcePath, w.BuildPath, w.RunsPath}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}
	return nil
}

// Cleanup 删除工作空间
func (w *Workspace) Cleanup() error {
	logx.Infof("开始清理工作空间 路径: %s", w.RootPath)

	err := os.RemoveAll(w.RootPath)
	if err != nil {
		logx.Errorf("清理工作空间失败 路径: %s, 错误: %v", w.RootPath, err)
		return err
	}

	logx.Infof("工作空间清理完毕: %s", w.RootPath)
	return nil
}

// getLanguageConfig 查找并返回语言配置
func (w *Workspace) getLanguageConfig() (*config.LanguageConfig, error) {
	for _, l := range w.config.Languages {
		if l.Name == w.judgeSubmit.Language {
			return &l, nil
		}
	}
	return nil, fmt.Errorf("不支持的语言: %s", w.judgeSubmit.Language)
}

// SaveSourceCode 保存源代码
func (w *Workspace) SaveSourceCode() *dto.JudgeResultDto {
	// 判断语言是否支持
	langConfig, err := w.getLanguageConfig()
	if err != nil {
		// err 不为空，说明不支持的语言
		logx.Errorf(err.Error())
		result := dto.ConvertSubmitToResult(w.judgeSubmit)
		result.Status = dto.StatusSystemError
		result.Message = err.Error()
		return &result
	}

	// 设置工作空间语言配置
	w.langConfig = *langConfig

	fileName := w.langConfig.SourceFile + w.langConfig.Extension // 设置源代码文件名
	filePath := filepath.Join(w.SourcePath, fileName)            // 源文件路径
	// 写入文件
	if err := os.WriteFile(filePath, []byte(w.judgeSubmit.Code), 0644); err != nil {
		logx.Errorf("写入源代码文件失败: %v", err)
		result := dto.ConvertSubmitToResult(w.judgeSubmit)
		result.Status = dto.StatusSystemError
		result.Message = fmt.Sprintf("写入源代码文件失败：%v", err)
		return &result
	}
	// 设置工作空间源代码文件路径（编译用）和编译文件路径（执行用）
	w.SourceFile = filePath
	w.BuildFile = filepath.Join(w.BuildPath, w.langConfig.CompileFile)
	logx.Infof("源代码保存成功: %s", filePath)
	return nil
}

// 执行代码
func (w *Workspace) Execute() (*dto.JudgeResultDto, error) {
	sandbox := NewSandbox(w.ctx, *w)

	langConfig, err := w.getLanguageConfig()
	if err != nil {
		return nil, fmt.Errorf("获取语言配置失败: %v", err)
	}

	// 调试日志
	logx.Infof("语言: %s, 编译命令长度: %d", w.judgeSubmit.Language, len(langConfig.CompileCmd))

	// 如果编译命令不为空，执行编译
	if len(langConfig.CompileCmd) > 0 {
		// 沙箱编译
		compileResult, err := sandbox.Compile()
		// 不为空说明出错了
		if err != nil {
			if compileResult.Message != "" {
				compileResult.Message = grutil.FilterFilePath(compileResult.Message)
			}
			return compileResult, err // 编译结果到这里结束
		}
	}

	// 沙箱运行
	runResult, _ := sandbox.Run()

	// 结果评估
	evaluateResult, _ := sandbox.Evaluater(runResult)
	if evaluateResult.Message != "" {
		evaluateResult.Message = grutil.FilterFilePath(evaluateResult.Message)
	}

	// 运行成功，返回运行结果给上级
	return evaluateResult, nil
}

internal/logic/common.go:
package logic

import (
	"context"
	"encoding/json"
	"judge-service/internal/dto"
	"judge-service/internal/judge"
	"judge-service/internal/svc"
	"sync"
	"time"

	"github.com/streadway/amqp"
	"github.com/zeromicro/go-zero/core/logx"
)

type CommonLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 题目逻辑
func NewCommonLogic(ctx context.Context, svcCtx *svc.ServiceContext) *CommonLogic {
	return &CommonLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

// 开始消费者
func (l *CommonLogic) StartConsumer() {
	// 声明队列（确保存在）
	_, err := l.svcCtx.CommonChannel.QueueDeclare(
		l.svcCtx.Config.RabbitMQ.Common.JudgeQueue,
		true, false, false, false, nil,
	)
	if err != nil {
		logx.Errorf("无法声明问题队列: %v", err)
		return
	}

	// 设置预取计数，控制并发度
	err = l.svcCtx.CommonChannel.Qos(
		10,    // 预取计数，控制并发处理的消息数量
		0,     // 预取大小，0表示无限制
		false, // 全局设置，false表示只对当前channel有效
	)
	if err != nil {
		logx.Errorf("设置Qos失败: %v", err)
		return
	}

	msgs, err := l.svcCtx.CommonChannel.Consume(
		l.svcCtx.Config.RabbitMQ.Common.JudgeQueue,
		"", false, false, false, false, nil,
	)
	if err != nil {
		logx.Errorf("注册题目消费者失败: %v", err)
		return
	}

	logx.Info("题目消费者已成功启动")

	var wg sync.WaitGroup
	semaphore := make(chan struct{}, 10) // 控制并发数量的信号量

	for d := range msgs {
		semaphore <- struct{}{} // 获取信号量
		wg.Add(1)

		go func(delivery amqp.Delivery) {
			defer wg.Done()
			defer func() { <-semaphore }() // 释放信号量

			l.processMessage(delivery)
		}(d)
	}

	wg.Wait() // 等待所有处理完成
}

func (l *CommonLogic) processMessage(delivery amqp.Delivery) {
	defer func() {
		if err := delivery.Ack(false); err != nil {
			logx.Errorf("未能确认题目消息: %v", err)
		}
	}()

	var judgeSubmit dto.JudgeSubmitDto
	if err := json.Unmarshal(delivery.Body, &judgeSubmit); err != nil {
		logx.Errorf("解码 JSON 出错: %v", err)
		// 打印body
		logx.Errorf("消息内容: %s", string(delivery.Body))
		return
	}

	logx.Infof("收到消息: %+v", judgeSubmit)

	workspace, workspaceResultDto := judge.NewWorkspace(l.ctx, l.svcCtx.Config, judgeSubmit, l.svcCtx)
	if workspaceResultDto != nil {
		err := l.sendResultToMQ(workspaceResultDto)
		if err != nil {
			logx.Errorf("发送结果到MQ失败: %v", err)
		}
		return
	}

	// 正常执行

	// 保存代码
	SourceCodeResultDto := workspace.SaveSourceCode()
	// SourceCodeResultDto 不为空说明出错了
	if SourceCodeResultDto != nil {
		err := l.sendResultToMQ(SourceCodeResultDto)
		if err != nil {
			logx.Errorf("发送结果到MQ失败: %v", err)
		}
		workspace.Cleanup()
		return
	}

	// 程序执行
	RunResultDto, err := workspace.Execute()
	logx.Infof("执行结果: %+v", RunResultDto)
	// 不为空说明出错了
	if err != nil {
		err := l.sendResultToMQ(RunResultDto)
		if err != nil {
			logx.Errorf("发送结果到MQ失败: %v", err)
		}
		workspace.Cleanup()
		return
	}

	logx.Infof("消息开始返回")
	// 如果正常会执行到这里
	err = l.sendResultToMQ(RunResultDto)
	if err != nil {
		logx.Errorf("发送结果到MQ失败: %v", err)
		err = workspace.Cleanup()
		if err != nil {
			logx.Errorf("删除工作空间失败: %v", err)
		}
		return
	}

	logx.Infof("消息返回成功")
	err = workspace.Cleanup()
	if err != nil {
		logx.Errorf("删除工作空间失败: %v", err)
		return
	}
}

func (l *CommonLogic) sendResultToMQ(result *dto.JudgeResultDto) error {
	body, err := json.Marshal(result)
	if err != nil {
		return err
	}

	exchange := l.svcCtx.Config.RabbitMQ.Common.ResultExchange
	routingKey := l.svcCtx.Config.RabbitMQ.Common.ResultRoutingKey

	err = l.svcCtx.CommonChannel.Publish(
		exchange,
		routingKey,
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        body,
			Timestamp:   time.Now(),
		},
	)
	return err
}

internal/logic/consume.go:
package logic

import (
	"context"
	"judge-service/internal/svc"
)

type ConsumeLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewConsumeLogic(ctx context.Context, svcCtx *svc.ServiceContext) *ConsumeLogic {
	return &ConsumeLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *ConsumeLogic) StartConsuming() {
	go NewCommonLogic(l.ctx, l.svcCtx).StartConsumer()

	// 阻塞主goroutine
	forever := make(chan bool)
	<-forever
}

internal/model/data_judge_case.go:
package model

import (
	"time"
)

// 判题结果用例表
type DataJudgeCase struct {
	ID             string     `gorm:"column:id;primaryKey;type:varchar(32)"`
	SubmitID       string     `gorm:"column:submit_id;type:varchar(32);not null"`
	CaseSign       string     `gorm:"column:case_sign;type:varchar(255)"`
	InputData      string     `gorm:"column:input_data;type:longtext"`
	OutputData     string     `gorm:"column:output_data;type:longtext"`
	ExpectedOutput string     `gorm:"column:expected_output;type:longtext"`
	InputFilePath  string     `gorm:"column:input_file_path;type:varchar(500)"`
	InputFileSize  int64      `gorm:"column:input_file_size;default:0"`
	OutputFilePath string     `gorm:"column:output_file_path;type:varchar(500)"`
	OutputFileSize int64      `gorm:"column:output_file_size;default:0"`
	MaxTime        float64    `gorm:"column:max_time;type:decimal(10,2);default:0.00"`
	MaxMemory      float64    `gorm:"column:max_memory;type:decimal(10,2);default:0.00"`
	IsSample       bool       `gorm:"column:is_sample;default:false"`
	Score          float64    `gorm:"column:score;type:decimal(10,2);default:0.00"`
	Status         string     `gorm:"column:status;type:varchar(32)"`
	Message        string     `gorm:"column:message;type:text"`
	ExitCode       int        `gorm:"column:exit_code;default:0"`
	Deleted        bool       `gorm:"column:deleted;default:false"`
	CreateTime     *time.Time `gorm:"column:create_time"`
	CreateUser     string     `gorm:"column:create_user;type:varchar(32)"`
	UpdateTime     *time.Time `gorm:"column:update_time"`
	UpdateUser     string     `gorm:"column:update_user;type:varchar(32)"`
}

func (DataJudgeCase) TableName() string {
	return "data_judge_case"
}

internal/model/data_test_case.go:
package model

import (
	"time"
)

// 题目测试用例表
type DataTestCase struct {
	ID             string     `gorm:"column:id;primaryKey;type:varchar(32)"`
	ProblemID      string     `gorm:"column:problem_id;type:varchar(32);not null"`
	CaseSign       string     `gorm:"column:case_sign;type:varchar(255)"`
	InputData      string     `gorm:"column:input_data;type:longtext"`
	ExpectedOutput string     `gorm:"column:expected_output;type:longtext"`
	InputFilePath  string     `gorm:"column:input_file_path;type:varchar(500)"`
	InputFileSize  int64      `gorm:"column:input_file_size;default:0"`
	OutputFilePath string     `gorm:"column:output_file_path;type:varchar(500)"`
	OutputFileSize int64      `gorm:"column:output_file_size;default:0"`
	IsSample       bool       `gorm:"column:is_sample;default:false"`
	Score          float64    `gorm:"column:score;type:decimal(10,2);default:0.00"`
	Deleted        bool       `gorm:"column:deleted;default:false"`
	CreateTime     *time.Time `gorm:"column:create_time"`
	CreateUser     string     `gorm:"column:create_user;type:varchar(32)"`
	UpdateTime     *time.Time `gorm:"column:update_time"`
	UpdateUser     string     `gorm:"column:update_user;type:varchar(32)"`
}

func (DataTestCase) TableName() string {
	return "data_test_case"
}

internal/nacos/nacos.go:
package nacos

import (
	"fmt"
	"strings"

	"github.com/nacos-group/nacos-sdk-go/v2/clients"
	"github.com/nacos-group/nacos-sdk-go/v2/clients/config_client"
	"github.com/nacos-group/nacos-sdk-go/v2/common/constant"
	"github.com/nacos-group/nacos-sdk-go/v2/vo"
	"github.com/zeromicro/go-zero/core/logx"
)

type ConfigManager struct {
	client config_client.IConfigClient
	group  string
}

func NewNacosConfigManager(serverAddr, username, password, namespace, group string) (*ConfigManager, error) {
	if serverAddr == "" {
		return nil, fmt.Errorf("Nacos服务器地址不能为空")
	}

	// 解析服务器地址，处理端口
	serverConfigs, err := parseServerConfigs(serverAddr)
	if err != nil {
		return nil, err
	}

	// 创建 clientConfig
	clientConfig := constant.ClientConfig{
		NamespaceId:         namespace,
		TimeoutMs:           10000, // 增加超时时间
		NotLoadCacheAtStart: true,
		LogDir:              "/tmp/nacos/log",
		CacheDir:            "/tmp/nacos/cache",
		LogLevel:            "error", // 降低日志级别
		Username:            username,
		Password:            password,
	}

	// 如果用户名和密码都为空，则不设置认证
	if username == "" && password == "" {
		clientConfig.Username = ""
		clientConfig.Password = ""
	}

	// 创建配置客户端
	configClient, err := clients.NewConfigClient(
		vo.NacosClientParam{
			ClientConfig:  &clientConfig,
			ServerConfigs: serverConfigs,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("创建Nacos配置客户端失败: %v", err)
	}

	return &ConfigManager{
		client: configClient,
		group:  group,
	}, nil
}

// parseServerConfigs 解析服务器地址
func parseServerConfigs(serverAddr string) ([]constant.ServerConfig, error) {
	var serverConfigs []constant.ServerConfig

	// 支持多个服务器地址（逗号分隔）
	addrs := strings.Split(serverAddr, ",")
	for _, addr := range addrs {
		addr = strings.TrimSpace(addr)
		if addr == "" {
			continue
		}

		// 解析主机和端口
		var host string
		var port uint64 = 8848 // 默认端口

		if strings.Contains(addr, ":") {
			parts := strings.Split(addr, ":")
			if len(parts) != 2 {
				return nil, fmt.Errorf("服务器地址格式无效: %s", addr)
			}
			host = parts[0]
			// 这里可以解析端口，但 Nacos SDK 通常使用默认端口
			// portStr := parts[1]
			// 如果需要自定义端口，可以在这里解析
		} else {
			host = addr
		}

		serverConfigs = append(serverConfigs, constant.ServerConfig{
			IpAddr:      host,
			Port:        port,
			ContextPath: "/nacos",
			Scheme:      "http", // 明确指定协议
		})
	}

	if len(serverConfigs) == 0 {
		return nil, fmt.Errorf("未找到有效的服务器地址")
	}

	return serverConfigs, nil
}

// GetConfig 从 Nacos 获取配置
func (m *ConfigManager) GetConfig(dataId string) (string, error) {
	if dataId == "" {
		return "", fmt.Errorf("dataId不能为空")
	}

	content, err := m.client.GetConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
	})
	if err != nil {
		return "", fmt.Errorf("从Nacos获取配置失败: %v", err)
	}

	if content == "" {
		return "", fmt.Errorf("配置内容为空, dataId: %s, group: %s", dataId, m.group)
	}

	return content, nil
}

// CheckConfigExists 检查配置是否存在
func (m *ConfigManager) CheckConfigExists(dataId string) (bool, error) {
	content, err := m.client.GetConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
	})
	if err != nil {
		return false, err
	}
	return content != "", nil
}

func (m *ConfigManager) ListenConfig(dataId string, onConfigChange func(string)) error {
	err := m.client.ListenConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
		OnChange: func(namespace, group, dataId, data string) {
			logx.Infof("配置已更新：命名空间=%s，组别=%s，数据ID=%s", namespace, group, dataId)
			onConfigChange(data)
		},
	})
	if err != nil {
		return fmt.Errorf("监听配置失败: %v", err)
	}
	logx.Infof("开始监听配置变更，数据ID：%s，组别：%s", dataId, m.group)
	return nil
}

// CancelListenConfig 取消监听配置
func (m *ConfigManager) CancelListenConfig(dataId string) error {
	err := m.client.CancelListenConfig(vo.ConfigParam{
		DataId: dataId,
		Group:  m.group,
	})
	if err != nil {
		return fmt.Errorf("取消监听配置失败: %v", err)
	}
	logx.Infof("已取消监听配置变更，数据ID：%s，组别：%s", dataId, m.group)
	return nil
}

internal/nacos/registry.go:
package nacos

import (
	"fmt"
	"judge-service/internal/config"
	"net"
	"strconv"
	"time"

	"github.com/nacos-group/nacos-sdk-go/v2/clients"
	"github.com/nacos-group/nacos-sdk-go/v2/clients/naming_client"
	"github.com/nacos-group/nacos-sdk-go/v2/common/constant"
	"github.com/nacos-group/nacos-sdk-go/v2/model"
	"github.com/nacos-group/nacos-sdk-go/v2/vo"
	"github.com/zeromicro/go-zero/core/logx"
)

// ServiceInstance 服务实例信息
type ServiceInstance struct {
	InstanceId  string            `json:"instanceId"`
	Ip          string            `json:"ip"`
	Port        uint64            `json:"port"`
	ServiceName string            `json:"serviceName"`
	Weight      float64           `json:"weight"`
	Healthy     bool              `json:"healthy"`
	Enabled     bool              `json:"enabled"`
	Metadata    map[string]string `json:"metadata"`
	ClusterName string            `json:"clusterName"`
}

// ServiceRegistry 服务注册器
type ServiceRegistry struct {
	client      naming_client.INamingClient
	group       string
	serviceName string
	ip          string
	port        uint64
	metadata    map[string]string
	clusterName string
	instanceId  string
}

// NewServiceRegistry 创建服务注册器
func NewServiceRegistry(nacosConfig config.NacosConfig, serviceConfig config.Config) (*ServiceRegistry, error) {
	if nacosConfig.ServerAddr == "" {
		return nil, fmt.Errorf("Nacos服务器地址不能为空")
	}

	// 解析服务器地址
	serverConfigs, err := parseServerConfigs(nacosConfig.ServerAddr)
	if err != nil {
		return nil, err
	}

	// 创建 clientConfig
	clientConfig := constant.ClientConfig{
		NamespaceId:         nacosConfig.Namespace,
		TimeoutMs:           10000,
		NotLoadCacheAtStart: true,
		LogDir:              "/tmp/nacos/log",
		CacheDir:            "/tmp/nacos/cache",
		LogLevel:            "error",
		Username:            nacosConfig.Username,
		Password:            nacosConfig.Password,
	}

	// 如果用户名和密码都为空，则不设置认证
	if nacosConfig.Username == "" && nacosConfig.Password == "" {
		clientConfig.Username = ""
		clientConfig.Password = ""
	}

	// 创建命名客户端
	namingClient, err := clients.NewNamingClient(
		vo.NacosClientParam{
			ClientConfig:  &clientConfig,
			ServerConfigs: serverConfigs,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("创建Nacos命名客户端失败: %v", err)
	}

	// 解析服务端口
	port, err := strconv.ParseUint(strconv.Itoa(serviceConfig.Port), 10, 64)
	if err != nil {
		return nil, fmt.Errorf("端口号无效: %v", err)
	}

	// 获取自动检测的IP
	autoIP, err := getLocalIP()
	if err != nil {
		logx.Errorf("自动获取IP失败: %v，使用默认配置", err)
		autoIP = "0.0.0.0"
	}

	// 确定最终使用的IP
	finalIP := autoIP
	if serviceConfig.Host != "0.0.0.0" && serviceConfig.Host != "" {
		finalIP = serviceConfig.Host
		logx.Infof("使用配置的IP: %s (自动检测的IP: %s)", finalIP, autoIP)
	} else {
		logx.Infof("使用自动检测的IP: %s", finalIP)
	}

	logx.Infof("服务注册 IP: %s", finalIP)

	// 生成实例ID
	instanceId := fmt.Sprintf("%s-%s-%d", serviceConfig.Name, finalIP, port)

	return &ServiceRegistry{
		client:      namingClient,
		group:       nacosConfig.Group,
		serviceName: serviceConfig.Name,
		ip:          finalIP,
		port:        port,
		metadata: map[string]string{
			"version":   "1.0.0",
			"workspace": serviceConfig.Workspace,
			"port":      strconv.Itoa(serviceConfig.Port),
			"startTime": time.Now().Format(time.RFC3339),
		},
		clusterName: "DEFAULT",
		instanceId:  instanceId,
	}, nil
}

// 获取本机第一个非回环的IPv4地址
func getLocalIP() (string, error) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return "", err
	}

	for _, addr := range addrs {
		if ipNet, ok := addr.(*net.IPNet); ok && !ipNet.IP.IsLoopback() {
			if ipNet.IP.To4() != nil {
				return ipNet.IP.String(), nil
			}
		}
	}
	return "", fmt.Errorf("不能获取 IP 地址")
}

// Register 注册服务
func (r *ServiceRegistry) Register() error {
	param := vo.RegisterInstanceParam{
		Ip:          r.ip,
		Port:        r.port,
		ServiceName: r.serviceName,
		Weight:      10,
		Enable:      true,
		Healthy:     true,
		Ephemeral:   true,
		Metadata:    r.metadata,
		ClusterName: r.clusterName,
		GroupName:   r.group,
	}

	success, err := r.client.RegisterInstance(param)
	if err != nil {
		return fmt.Errorf("服务注册失败: %v", err)
	}

	if !success {
		return fmt.Errorf("服务注册未成功")
	}

	logx.Infof("服务注册成功: %s:%d, 实例ID: %s", r.ip, r.port, r.instanceId)
	return nil
}

// Deregister 注销服务
func (r *ServiceRegistry) Deregister() error {
	param := vo.DeregisterInstanceParam{
		Ip:          r.ip,
		Port:        r.port,
		ServiceName: r.serviceName,
		Cluster:     r.clusterName,
		GroupName:   r.group,
		Ephemeral:   true,
	}

	success, err := r.client.DeregisterInstance(param)
	if err != nil {
		return fmt.Errorf("服务注销失败: %v", err)
	}

	if !success {
		return fmt.Errorf("服务注销未成功")
	}

	logx.Infof("服务注销成功: %s:%d", r.ip, r.port)
	return nil
}

// SetMetadata 设置元数据
func (r *ServiceRegistry) SetMetadata(key, value string) {
	r.metadata[key] = value
}

// GetServiceInstances 获取服务实例列表
func (r *ServiceRegistry) GetServiceInstances(serviceName string) ([]ServiceInstance, error) {
	instances, err := r.client.SelectInstances(vo.SelectInstancesParam{
		ServiceName: serviceName,
		GroupName:   r.group,
		Clusters:    []string{r.clusterName},
		HealthyOnly: true,
	})
	if err != nil {
		return nil, fmt.Errorf("获取服务实例列表失败: %v", err)
	}

	var result []ServiceInstance
	for _, instance := range instances {
		result = append(result, ServiceInstance{
			InstanceId:  instance.InstanceId,
			Ip:          instance.Ip,
			Port:        instance.Port,
			ServiceName: instance.ServiceName,
			Weight:      instance.Weight,
			Healthy:     instance.Healthy,
			Enabled:     instance.Enable,
			Metadata:    instance.Metadata,
			ClusterName: instance.ClusterName,
		})
	}
	return result, nil
}

// Subscribe 订阅服务变化
func (r *ServiceRegistry) Subscribe(serviceName string, callback func([]ServiceInstance)) error {
	err := r.client.Subscribe(&vo.SubscribeParam{
		ServiceName: serviceName,
		GroupName:   r.group,
		Clusters:    []string{r.clusterName},
		SubscribeCallback: func(services []model.Instance, err error) {
			if err != nil {
				logx.Errorf("服务订阅回调错误: %v", err)
				return
			}

			var instances []ServiceInstance
			for _, service := range services {
				instances = append(instances, ServiceInstance{
					InstanceId:  service.InstanceId,
					Ip:          service.Ip,
					Port:        service.Port,
					ServiceName: service.ServiceName,
					Weight:      service.Weight,
					Healthy:     service.Healthy,
					Enabled:     service.Enable,
					Metadata:    service.Metadata,
					ClusterName: service.ClusterName,
				})
			}
			callback(instances)
		},
	})
	if err != nil {
		return fmt.Errorf("服务订阅失败: %v", err)
	}
	return nil
}

// Unsubscribe 取消订阅
func (r *ServiceRegistry) Unsubscribe(serviceName string) error {
	err := r.client.Unsubscribe(&vo.SubscribeParam{
		ServiceName: serviceName,
		GroupName:   r.group,
		Clusters:    []string{r.clusterName},
	})
	if err != nil {
		return fmt.Errorf("取消服务订阅失败: %v", err)
	}
	return nil
}

// HealthCheck 健康检查
func (r *ServiceRegistry) HealthCheck() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		// 发送心跳，更新服务状态
		_, err := r.client.GetService(vo.GetServiceParam{
			ServiceName: r.serviceName,
			GroupName:   r.group,
		})
		if err != nil {
			logx.Errorf("健康检查失败: %v", err)
			// 尝试重新注册
			if err := r.Register(); err != nil {
				logx.Errorf("健康检查失败后重新注册服务失败: %v", err)
			} else {
				logx.Info("健康检查失败后服务重新注册成功")
			}
		} else {
			logx.Debugf("服务健康检查通过: %s", r.serviceName)
		}
	}
}

// GetServiceInfo 获取服务信息
func (r *ServiceRegistry) GetServiceInfo() ServiceInstance {
	return ServiceInstance{
		InstanceId:  r.instanceId,
		Ip:          r.ip,
		Port:        r.port,
		ServiceName: r.serviceName,
		Weight:      10,
		Healthy:     true,
		Enabled:     true,
		Metadata:    r.metadata,
		ClusterName: r.clusterName,
	}
}

internal/repository/testcase_repository.go:
package repository

import (
	"context"
	"fmt"
	"judge-service/internal/model"

	"github.com/zeromicro/go-zero/core/logx"
	"gorm.io/gorm"
)

type TestCaseRepository interface {
	GetTestCasesByProblemID(ctx context.Context, problemID string) ([]model.DataTestCase, error)
}

type testCaseRepository struct {
	db *gorm.DB
}

func NewTestCaseRepository(db *gorm.DB) TestCaseRepository {
	return &testCaseRepository{
		db: db,
	}
}

func (r *testCaseRepository) GetTestCasesByProblemID(ctx context.Context, problemID string) ([]model.DataTestCase, error) {
	if r.db == nil {
		return nil, fmt.Errorf("database is not ready")
	}

	// 添加调试日志
	logx.Infof("开始查询题目 %s 的测试用例", problemID)

	var testCases []model.DataTestCase
	err := r.db.
		Where("problem_id = ?", problemID).
		Order("create_time ASC").
		Find(&testCases).Error

	if err != nil {
		return nil, fmt.Errorf("获取测试用例失败: %v", err)
	}

	logx.Infof("成功获取题目 %s 的测试用例，共 %d 条", problemID, len(testCases))

	// 如果没有数据，记录警告
	if len(testCases) == 0 {
		logx.Infof("题目 %s 没有找到未删除的测试用例", problemID)
	}

	return testCases, nil
}

internal/svc/servicecontext.go:
package svc

import (
	"fmt"
	"judge-service/internal/config"
	"judge-service/internal/nacos"
	"judge-service/internal/repository"
	"log"
	"time"

	"github.com/streadway/amqp"
	"github.com/zeromicro/go-zero/core/logx"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type ServiceContext struct {
	Config          config.Config
	DB              *gorm.DB // GORM 数据库实例
	RabbitMQ        *amqp.Connection
	CommonChannel   *amqp.Channel
	ServiceRegistry *nacos.ServiceRegistry // 服务注册器
	TestCaseRepo    repository.TestCaseRepository
}

func NewServiceContext(c config.Config) *ServiceContext {
	// 创建连接
	conn, err := amqp.DialConfig(c.RabbitMQ.Host, amqp.Config{
		Vhost: c.RabbitMQ.VirtualHost,
	})
	if err != nil {
		logx.Errorf("无法连接到 RabbitMQ: %v", err)
		panic(err)
	}

	// 常规通道
	commonCh, err := conn.Channel()
	if err != nil {
		logx.Errorf("无法打开通道: %v", err)
		panic(err)
	}

	// 创建服务注册器
	var serviceRegistry *nacos.ServiceRegistry
	if c.Nacos.ServerAddr != "" {
		registry, err := nacos.NewServiceRegistry(c.Nacos, c)
		if err != nil {
			logx.Errorf("创建服务注册器失败: %v", err)
			// 不 panic，让服务继续运行
		} else {
			serviceRegistry = registry

			// 注册服务到 Nacos
			if err := serviceRegistry.Register(); err != nil {
				logx.Errorf("服务注册失败: %v", err)
			} else {
				logx.Info("服务成功注册到 Nacos")

				// 启动健康检查
				go serviceRegistry.HealthCheck()
			}
		}
	}

	ctx := &ServiceContext{
		Config:          c,
		RabbitMQ:        conn,
		CommonChannel:   commonCh,
		ServiceRegistry: serviceRegistry,
	}

	// 异步初始化 MySQL，支持重试
	go ctx.initMySQLWithRetry()

	return ctx
}

// initMySQL 初始化 MySQL 连接
func initMySQL(c config.MySQLConfig) (*gorm.DB, error) {
	// 构建 DSN
	dsn := c.Username + ":" + c.Password + "@tcp(" + c.Host + ")/" + c.Database +
		"?charset=" + c.Charset + "&parseTime=" + boolToString(c.ParseTime) + "&loc=" + c.Loc

	// 自定义 GORM 日志
	newLogger := logger.New(
		log.New(log.Writer(), "\r\n", log.LstdFlags), // io writer
		logger.Config{
			SlowThreshold:             time.Second,   // 慢 SQL 阈值
			LogLevel:                  logger.Silent, // 日志级别
			IgnoreRecordNotFoundError: true,          // 忽略ErrRecordNotFound（记录未找到）错误
			Colorful:                  false,         // 禁用彩色打印
		},
	)

	// 连接数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		return nil, err
	}

	// 获取通用的数据库对象 sql.DB ，然后使用其提供的功能
	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	// 设置连接池
	sqlDB.SetMaxIdleConns(c.MaxIdleConns)
	sqlDB.SetMaxOpenConns(c.MaxOpenConns)

	// 解析连接最大生命周期
	if maxLifetime, err := time.ParseDuration(c.ConnMaxLifetime); err == nil {
		sqlDB.SetConnMaxLifetime(maxLifetime)
	}

	// 自动迁移表结构
	// err = db.AutoMigrate(
	// 	&model.DataJudgeCase{},
	// 	&model.DataTestCase{},
	// )
	if err != nil {
		logx.Errorf("自动迁移表结构失败: %v", err)
	}

	logx.Info("MySQL 连接成功")
	return db, nil
}

func boolToString(b bool) string {
	if b {
		return "True"
	}
	return "False"
}

func (s *ServiceContext) initMySQLWithRetry() {
	maxRetries := 5
	retryInterval := time.Second * 5

	for i := 0; i < maxRetries; i++ {
		db, err := initMySQL(s.Config.MySQL)
		if err != nil {
			logx.Errorf("初始化 MySQL 失败 (尝试 %d/%d): %v", i+1, maxRetries, err)

			if i == maxRetries-1 {
				logx.Error("已达到最大重试次数，MySQL 连接失败")
				return
			}

			logx.Infof("%v 后重试...", retryInterval)
			time.Sleep(retryInterval)
			continue
		}

		s.DB = db
		s.TestCaseRepo = repository.NewTestCaseRepository(db)
		logx.Info("MySQL 连接成功")
		return
	}
}

// 检查数据库连接状态的方法
func (s *ServiceContext) IsDBReady() bool {
	return s.DB != nil
}

// 安全地使用数据库
func (s *ServiceContext) SafeDB() (*gorm.DB, error) {
	if s.DB == nil {
		return nil, fmt.Errorf("数据库未初始化")
	}
	return s.DB, nil
}

